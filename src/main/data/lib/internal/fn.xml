<xqdoc:xqdoc xmlns:xqdoc="http://www.xqdoc.org/1.0">
 <xqdoc:control>
  <xqdoc:date>2019-05-14T12:08:24.519-04:00</xqdoc:date>
  <xqdoc:location>java:org.exist.xquery.functions.fn.FnModule</xqdoc:location>
 </xqdoc:control>
 <xqdoc:module type="library">
  <xqdoc:uri>http://www.w3.org/2005/xpath-functions</xqdoc:uri>
  <xqdoc:name/>
  <xqdoc:comment>
   <xqdoc:description>A module with the XQuery/XPath Core Library Functions</xqdoc:description>
  </xqdoc:comment>
 </xqdoc:module>
 <xqdoc:functions>
  <xqdoc:function>
   <xqdoc:name>QName</xqdoc:name>
   <xqdoc:signature>QName($uri as xs:string?, $qname as xs:string) as xs:QName</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:QName with the namespace URI given in $uri. If $uri is the zero-length string or the empty sequence, it represents "no namespace"; in this case, if the value of $qname contains a colon (:), an error is raised [err:FOCA0002]. The prefix (or absence of a prefix) in $qname is retained in the returned xs:QName value. The local name in the result is taken from the local part of $qname.

If $qname does not have the correct lexical form for xs:QName an error is raised [err:FOCA0002].

Note that unlike xs:QName this function does not require a xs:string literal as the argument.</xqdoc:description>
    <xqdoc:param>$uri? The namespace URI</xqdoc:param>
    <xqdoc:param>$qname The prefix</xqdoc:param>
    <xqdoc:return>xs:QName : the xs:QName with the namespace URI given in $uri</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>abs</xqdoc:name>
   <xqdoc:signature>abs($number as xs:numeric?) as xs:numeric?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the absolute value of the argument $number.If the argument is negative returns -$number otherwise returns $number.</xqdoc:description>
    <xqdoc:param>$number? The number</xqdoc:param>
    <xqdoc:return>xs:numeric? : The absolute value of the argument</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>adjust-date-to-timezone</xqdoc:name>
   <xqdoc:signature>adjust-date-to-timezone($date as xs:date?) as xs:date?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Adjusts the xs:date value $date to the implicit timezone of the current locale.</xqdoc:description>
    <xqdoc:param>$date? The date</xqdoc:param>
    <xqdoc:return>xs:date? : the adjusted date</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>adjust-date-to-timezone</xqdoc:name>
   <xqdoc:signature>adjust-date-to-timezone($date as xs:date?, $duration as xs:dayTimeDuration?) as xs:date?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Adjusts the xs:date value $date to a specific timezone, or to no timezone at all. If $duration is the empty sequence, returns an xs:date without a timezone.</xqdoc:description>
    <xqdoc:param>$date? The date</xqdoc:param>
    <xqdoc:param>$duration? The duration</xqdoc:param>
    <xqdoc:return>xs:date? : the adjusted date</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>adjust-dateTime-to-timezone</xqdoc:name>
   <xqdoc:signature>adjust-dateTime-to-timezone($date-time as xs:dateTime?) as xs:dateTime?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Adjusts the xs:dateTime value $date-time to the implicit timezone of the current locale.</xqdoc:description>
    <xqdoc:param>$date-time? The date-time</xqdoc:param>
    <xqdoc:return>xs:dateTime? : the adjusted date-time</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>adjust-dateTime-to-timezone</xqdoc:name>
   <xqdoc:signature>adjust-dateTime-to-timezone($date-time as xs:dateTime?, $duration as xs:dayTimeDuration?) as xs:dateTime?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Adjusts the xs:dateTime value $date-time to a specific timezone, or to no timezone at all. If $duration is the empty sequence, returns an xs:dateTime without a timezone.</xqdoc:description>
    <xqdoc:param>$date-time? The date-time</xqdoc:param>
    <xqdoc:param>$duration? The duration</xqdoc:param>
    <xqdoc:return>xs:dateTime? : the adjusted date-time</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>adjust-time-to-timezone</xqdoc:name>
   <xqdoc:signature>adjust-time-to-timezone($time as xs:time?) as xs:time?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Adjusts the xs:time value $time to the implicit timezone of the current locale.</xqdoc:description>
    <xqdoc:param>$time? The time</xqdoc:param>
    <xqdoc:return>xs:time? : the adjusted time</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>adjust-time-to-timezone</xqdoc:name>
   <xqdoc:signature>adjust-time-to-timezone($time as xs:time?, $duration as xs:dayTimeDuration?) as xs:time?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Adjusts the xs:time value $time to a specific timezone, or to no timezone at all. If $duration is the empty sequence, returns an xs:time without a timezone.</xqdoc:description>
    <xqdoc:param>$time? The time</xqdoc:param>
    <xqdoc:param>$duration? The duration</xqdoc:param>
    <xqdoc:return>xs:time? : the adjusted time</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>analyze-string</xqdoc:name>
   <xqdoc:signature>analyze-string($input as xs:string?, $pattern as xs:string) as element()</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Analyzes a string using a regular expression, returning an XML structure that identifies which parts of the input string matched or failed to match the regular expression, and in the case of matched substrings, which substrings matched each capturing group in the regular expression.</xqdoc:description>
    <xqdoc:param>$input? The input string</xqdoc:param>
    <xqdoc:param>$pattern The pattern</xqdoc:param>
    <xqdoc:return>element() : The result of the analysis</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>analyze-string</xqdoc:name>
   <xqdoc:signature>analyze-string($input as xs:string?, $pattern as xs:string, $flags as xs:string) as element()</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Analyzes a string using a regular expression, returning an XML structure that identifies which parts of the input string matched or failed to match the regular expression, and in the case of matched substrings, which substrings matched each capturing group in the regular expression.</xqdoc:description>
    <xqdoc:param>$input? The input string</xqdoc:param>
    <xqdoc:param>$pattern The pattern</xqdoc:param>
    <xqdoc:param>$flags Flags</xqdoc:param>
    <xqdoc:return>element() : The result of the analysis</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>apply</xqdoc:name>
   <xqdoc:signature>apply($function as function(*), $array as array(*)) as item()*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Processes the supplied sequence from right to left, applying the supplied function repeatedly to each item in turn, together with an accumulated result value.</xqdoc:description>
    <xqdoc:param>$function the function to call</xqdoc:param>
    <xqdoc:param>$array an array containing the arguments to pass to the function</xqdoc:param>
    <xqdoc:return>item()* : return value of the function call</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>available-environment-variables</xqdoc:name>
   <xqdoc:signature>available-environment-variables() as xs:string*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns a list of environment variable names.</xqdoc:description>
    <xqdoc:return>xs:string* : Returns a sequence of strings, being the names of the environment variables. User must be DBA.</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>avg</xqdoc:name>
   <xqdoc:signature>avg($values as xs:anyAtomicType*) as xs:anyAtomicType?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the average of the values in the input sequence $values, that is, the sum of the values divided by the number of values.</xqdoc:description>
    <xqdoc:param>$values* The values</xqdoc:param>
    <xqdoc:return>xs:anyAtomicType? : The average of the values in the input sequence</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>base-uri</xqdoc:name>
   <xqdoc:signature>base-uri() as xs:anyURI?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the value of the base URI property for the context item.</xqdoc:description>
    <xqdoc:return>xs:anyURI? : The base URI from the context item</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>base-uri</xqdoc:name>
   <xqdoc:signature>base-uri($uri as node()?) as xs:anyURI?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the value of the base URI property for $uri. If $uri is the empty sequence, the empty sequence is returned.</xqdoc:description>
    <xqdoc:param>$uri? The URI</xqdoc:param>
    <xqdoc:return>xs:anyURI? : the base URI from $uri</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>boolean</xqdoc:name>
   <xqdoc:signature>boolean($items as item()*) as xs:boolean</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Computes the xs:boolean value of the sequence items.</xqdoc:description>
    <xqdoc:param>$items* The items</xqdoc:param>
    <xqdoc:return>xs:boolean : The boolean value, ebv, of the items</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>ceiling</xqdoc:name>
   <xqdoc:signature>ceiling($number as xs:numeric?) as xs:numeric?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns a value of the same type as the argument. Specifically, returns the smallest (closest to negative infinity) number with no fractional part that is not less than the value of the argument, $number.</xqdoc:description>
    <xqdoc:param>$number? The number</xqdoc:param>
    <xqdoc:return>xs:numeric? : The non-fractional number not less than $number</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>codepoint-equal</xqdoc:name>
   <xqdoc:signature>codepoint-equal($string-1 as xs:string?, $string-2 as xs:string?) as xs:boolean?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns true or false depending on whether the value of $string-1 is equal to the value of $string-2, according to the Unicode code point collation.</xqdoc:description>
    <xqdoc:param>$string-1? The first string</xqdoc:param>
    <xqdoc:param>$string-2? The second string</xqdoc:param>
    <xqdoc:return>xs:boolean? : true() if the codepoints are equal, false() otherwise</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>codepoints-to-string</xqdoc:name>
   <xqdoc:signature>codepoints-to-string($codepoints as xs:integer*) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Creates an xs:string from a sequence of code points. Returns the zero-length string if $codepoints is the empty sequence. If any of the code points in $codepoints is not a legal XML character, an error is raised</xqdoc:description>
    <xqdoc:param>$codepoints* The codepoints as a sequence of xs:integer values</xqdoc:param>
    <xqdoc:return>xs:string : The string constructed from the codepoints if valid</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>collection</xqdoc:name>
   <xqdoc:signature>collection($collection-uris as xs:string*) as item()*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the documents contained in the collections specified in the input sequence. Collection URIs can be specified either as a simple collection path or an XMLDB URI. Documents contained in sub-collections are also included. If no value is supplied, the statically know documents are used, for the REST Server this could be the addressed collection.</xqdoc:description>
    <xqdoc:param>$collection-uris* The collection-URIs for which to include the documents</xqdoc:param>
    <xqdoc:return>item()* : The document nodes contained in or under the given collections</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>compare</xqdoc:name>
   <xqdoc:signature>compare($string-1 as xs:string?, $string-2 as xs:string?) as xs:integer?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the collatable comparison between $string-1 and $string-2, using $collation-uri. -1 if $string-1 is inferior to $string-2, 0 if $string-1 is equal to $string-2, 1 if $string-1 is superior to $string-2. If either comparand is the empty sequence, the empty sequence is returned. Please remember to specify the collation in the context or use, the three argument version if you don't want the system default.</xqdoc:description>
    <xqdoc:param>$string-1? The first string</xqdoc:param>
    <xqdoc:param>$string-2? The second string</xqdoc:param>
    <xqdoc:return>xs:integer? : -1 if $string-1 is inferior to $string-2, 0 if $string-1 is equal to $string-2, 1 if $string-1 is superior to $string-2. If either comparand is the empty sequence, the empty sequence is returned.</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>compare</xqdoc:name>
   <xqdoc:signature>compare($string-1 as xs:string?, $string-2 as xs:string?, $collation-uri as xs:string) as xs:integer?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the collatable comparison between $string-1 and $string-2, using $collation-uri. -1 if $string-1 is inferior to $string-2, 0 if $string-1 is equal to $string-2, 1 if $string-1 is superior to $string-2. If either comparand is the empty sequence, the empty sequence is returned. The third argument $collation-uri is either: 1) the full URI e.g. "http://www.w3.org/2013/collation/UCA?lang=en;strength=secondary", or 2) relative where you only need to specify the last part of a valid full collation-uri, e.g. "?lang=sv-SE", "lang=sv-SE;strength=primary;decomposition=standard" or "swedish".</xqdoc:description>
    <xqdoc:param>$string-1? The first string</xqdoc:param>
    <xqdoc:param>$string-2? The second string</xqdoc:param>
    <xqdoc:param>$collation-uri The relative collation URI</xqdoc:param>
    <xqdoc:return>xs:integer? : -1 if $string-1 is inferior to $string-2, 0 if $string-1 is equal to $string-2, 1 if $string-1 is superior to $string-2. If either comparand is the empty sequence, the empty sequence is returned.</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>concat</xqdoc:name>
   <xqdoc:signature>concat($atomizable-values as xs:anyAtomicType?) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Accepts two or more xdt:anyAtomicType arguments, $atomizable-values, and converts them to xs:string. Returns the xs:string that is the concatenation of the values of its arguments after conversion. If any of the arguments is the empty sequence, the argument is treated as the zero-length string.</xqdoc:description>
    <xqdoc:param>$atomizable-values? The atomizable values</xqdoc:param>
    <xqdoc:return>xs:string : The concatenated values</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>contains</xqdoc:name>
   <xqdoc:signature>contains($source-string as xs:string?, $substring as xs:string?) as xs:boolean</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:boolean indicating whether or not the value of $source-string contains (at the beginning, at the end, or anywhere within) at least one sequence of collation units that provides a minimal match to the collation units in the value of $substring, according to the default collation.</xqdoc:description>
    <xqdoc:param>$source-string? The source-string</xqdoc:param>
    <xqdoc:param>$substring? The substring</xqdoc:param>
    <xqdoc:return>xs:boolean : true() if $source-string contains $substring, false() otherwise</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>contains</xqdoc:name>
   <xqdoc:signature>contains($source-string as xs:string?, $substring as xs:string?, $collation-uri as xs:string) as xs:boolean</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:boolean indicating whether or not the value of $source-string contains (at the beginning, at the end, or anywhere within) at least one sequence of collation units that provides a minimal match to the collation units in the value of $substring, according to the collation that is specified in $collation-uri.The third argument $collation-uri is either: 1) the full URI e.g. "http://www.w3.org/2013/collation/UCA?lang=en;strength=secondary", or 2) relative where you only need to specify the last part of a valid full collation-uri, e.g. "?lang=sv-SE", "lang=sv-SE;strength=primary;decomposition=standard" or "swedish".</xqdoc:description>
    <xqdoc:param>$source-string? The source-string</xqdoc:param>
    <xqdoc:param>$substring? The substring</xqdoc:param>
    <xqdoc:param>$collation-uri The collation URI</xqdoc:param>
    <xqdoc:return>xs:boolean : true() if $source-string contains $substring, false() otherwise</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>count</xqdoc:name>
   <xqdoc:signature>count($items as item()*) as xs:integer</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the number of items in the argument sequence, $items.</xqdoc:description>
    <xqdoc:param>$items* The items</xqdoc:param>
    <xqdoc:return>xs:integer : The number of items in the argument sequence</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>current-date</xqdoc:name>
   <xqdoc:signature>current-date() as xs:date</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the xs:date (with timezone) that is current at some time during the evaluation of a query or transformation in which fn:current-date() is executed.</xqdoc:description>
    <xqdoc:return>xs:date : the date current within the query execution time span</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>current-dateTime</xqdoc:name>
   <xqdoc:signature>current-dateTime() as xs:dateTime</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the xs:dateTime (with timezone) that is current at some time during the evaluation of a query or transformation in which fn:current-dateTime() is executed.</xqdoc:description>
    <xqdoc:return>xs:dateTime : the date-time current within query execution time span</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>current-time</xqdoc:name>
   <xqdoc:signature>current-time() as xs:time</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the xs:time (with timezone) that is current at some time during the evaluation of a query or transformation in which fn:current-time() is executed.</xqdoc:description>
    <xqdoc:return>xs:time : the time current within query execution time span</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>data</xqdoc:name>
   <xqdoc:signature>data() as xs:anyAtomicType*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Atomizes the context item, replacing all nodes in the sequence by their typed values.</xqdoc:description>
    <xqdoc:return>xs:anyAtomicType* : the atomic values of the items in $items</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>data</xqdoc:name>
   <xqdoc:signature>data($items as item()*) as xs:anyAtomicType*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Atomizes the sequence $items, replacing all nodes in the sequence by their typed values.</xqdoc:description>
    <xqdoc:param>$items* The items</xqdoc:param>
    <xqdoc:return>xs:anyAtomicType* : the atomic values of the items in $items</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>dateTime</xqdoc:name>
   <xqdoc:signature>dateTime($date as xs:date?, $time as xs:time?) as xs:dateTime?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Creates an xs:dateTime from an xs:date, $date, and an xs:time, $time.</xqdoc:description>
    <xqdoc:param>$date? The date as xs:date</xqdoc:param>
    <xqdoc:param>$time? The time as xs:time</xqdoc:param>
    <xqdoc:return>xs:dateTime? : the combined date and time as xs:dateTime</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>day-from-date</xqdoc:name>
   <xqdoc:signature>day-from-date($date as xs:date?) as xs:integer?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:integer between 1 and 31, both inclusive, representing the day component in the localized value of $date.</xqdoc:description>
    <xqdoc:param>$date? The date as xs:date</xqdoc:param>
    <xqdoc:return>xs:integer? : the day component from $date</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>day-from-dateTime</xqdoc:name>
   <xqdoc:signature>day-from-dateTime($date-time as xs:dateTime?) as xs:integer?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:integer between 1 and 31, both inclusive, representing the day component in the localized value of $date-time.</xqdoc:description>
    <xqdoc:param>$date-time? The date-time as xs:dateTime</xqdoc:param>
    <xqdoc:return>xs:integer? : the day component from $date-time</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>days-from-duration</xqdoc:name>
   <xqdoc:signature>days-from-duration($duration as xs:duration?) as xs:integer?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:integer representing the days component in the canonical lexical representation of the value of $duration. The result may be negative.</xqdoc:description>
    <xqdoc:param>$duration? The duration as xs:duration</xqdoc:param>
    <xqdoc:return>xs:integer? : the days component of $duration</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>deep-equal</xqdoc:name>
   <xqdoc:signature>deep-equal($items-1 as item()*, $items-2 as item()*) as xs:boolean</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns true() iff every item in $items-1 is deep-equal to the item at the same position in $items-2, false() otherwise. If both $items-1 and $items-2 are the empty sequence, returns true(). </xqdoc:description>
    <xqdoc:param>$items-1* The first item sequence</xqdoc:param>
    <xqdoc:param>$items-2* The second item sequence</xqdoc:param>
    <xqdoc:return>xs:boolean : true() if the sequences are deep-equal, false() otherwise</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>deep-equal</xqdoc:name>
   <xqdoc:signature>deep-equal($items-1 as item()*, $items-2 as item()*, $collation-uri as xs:string) as xs:boolean</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns true() iff every item in $items-1 is deep-equal to the item at the same position in $items-2, false() otherwise. If both $items-1 and $items-2 are the empty sequence, returns true(). Comparison collation is specified by $collation-uri. The third argument $collation-uri is either: 1) the full URI e.g. "http://www.w3.org/2013/collation/UCA?lang=en;strength=secondary", or 2) relative where you only need to specify the last part of a valid full collation-uri, e.g. "?lang=sv-SE", "lang=sv-SE;strength=primary;decomposition=standard" or "swedish".</xqdoc:description>
    <xqdoc:param>$items-1* The first item sequence</xqdoc:param>
    <xqdoc:param>$items-2* The second item sequence</xqdoc:param>
    <xqdoc:param>$collation-uri The collation URI</xqdoc:param>
    <xqdoc:return>xs:boolean : true() if the sequences are deep-equal, false() otherwise</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>default-collation</xqdoc:name>
   <xqdoc:signature>default-collation() as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the context's default collation. E.g. http://www.w3.org/2005/xpath-functions/collation/codepoint.</xqdoc:description>
    <xqdoc:return>xs:string : the default collation from the context</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>distinct-values</xqdoc:name>
   <xqdoc:signature>distinct-values($atomic-values as xs:anyAtomicType*) as xs:anyAtomicType*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns a sequence where duplicate values of $atomic-values, based on value equality, have been deleted.</xqdoc:description>
    <xqdoc:param>$atomic-values* The atomic values</xqdoc:param>
    <xqdoc:return>xs:anyAtomicType* : the distinct values sequence</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>distinct-values</xqdoc:name>
   <xqdoc:signature>distinct-values($atomic-values as xs:anyAtomicType*, $collation-uri as xs:string) as xs:anyAtomicType*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns a sequence where duplicate values of $atomic-values, based on value equality specified by collation $collation-uri, have been deleted.</xqdoc:description>
    <xqdoc:param>$atomic-values* The atomic values</xqdoc:param>
    <xqdoc:param>$collation-uri The collation URI</xqdoc:param>
    <xqdoc:return>xs:anyAtomicType* : the distinct values sequence</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>doc</xqdoc:name>
   <xqdoc:signature>doc($document-uri as xs:string?) as document-node()?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the document node of $document-uri. Resource URIs can be specified either as a simple collection path, an XMLDB URI or any URI.</xqdoc:description>
    <xqdoc:param>$document-uri? The document URI</xqdoc:param>
    <xqdoc:return>document-node()? : the document node of $document-uri</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>doc-available</xqdoc:name>
   <xqdoc:signature>doc-available($document-uri as xs:string?) as xs:boolean</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns whether or not the document, $document-uri, specified in the input sequence is available. Resource URIs can be specified either as a simple collection path, an XMLDB URI or any URI.</xqdoc:description>
    <xqdoc:param>$document-uri? The document URI</xqdoc:param>
    <xqdoc:return>xs:boolean : true() if the document is available, false() otherwise</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>document-uri</xqdoc:name>
   <xqdoc:signature>document-uri($document-node as node()?) as xs:anyURI?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the absolute URI of the resource from which the document node $document-node was constructed. If none such URI exists returns the empty sequence. If $document-node is the empty sequence, returns the empty sequence.</xqdoc:description>
    <xqdoc:param>$document-node? The document node</xqdoc:param>
    <xqdoc:return>xs:anyURI? : the document URI of $document-node</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>empty</xqdoc:name>
   <xqdoc:signature>empty($items as item()*) as xs:boolean</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns true() if the value of $items is the empty sequence, false() otherwise.</xqdoc:description>
    <xqdoc:param>$items* The item sequence</xqdoc:param>
    <xqdoc:return>xs:boolean : true() if the empty sequence, false() otherwise</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>encode-for-uri</xqdoc:name>
   <xqdoc:signature>encode-for-uri($uri-part as xs:string?) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Escapes reserved characters in $uri-part by replacing it with its percent-encoded form as described in [RFC 3986]. If $uri-part is the empty sequence, returns the zero-length string.</xqdoc:description>
    <xqdoc:param>$uri-part? The URI part to encode</xqdoc:param>
    <xqdoc:return>xs:string : the URI part with reserved characters percent encoded</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>ends-with</xqdoc:name>
   <xqdoc:signature>ends-with($source-string as xs:string?, $suffix as xs:string?) as xs:boolean</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns true() if the string value of $suffix is a suffix of the string value of $source-string, false() otherwise. If either $source-string or $suffix is the empty sequence, the empty sequence is returned.</xqdoc:description>
    <xqdoc:param>$source-string? The source-string</xqdoc:param>
    <xqdoc:param>$suffix? The suffix</xqdoc:param>
    <xqdoc:return>xs:boolean : true() if $suffix is suffix of $source-string, false() otherwise</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>ends-with</xqdoc:name>
   <xqdoc:signature>ends-with($source-string as xs:string?, $suffix as xs:string?, $collation-uri as xs:string) as xs:boolean</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns true() if the string value of $suffix is a suffix of the string value of $source-string using collation $collation-uri, false() otherwise. If either $source-string or $suffix is the empty sequence, the empty sequence is returned. The third argument $collation-uri is either: 1) the full URI e.g. "http://www.w3.org/2013/collation/UCA?lang=en;strength=secondary", or 2) relative where you only need to specify the last part of a valid full collation-uri, e.g. "?lang=sv-SE", "lang=sv-SE;strength=primary;decomposition=standard" or "swedish".</xqdoc:description>
    <xqdoc:param>$source-string? The source string</xqdoc:param>
    <xqdoc:param>$suffix? The suffix</xqdoc:param>
    <xqdoc:param>$collation-uri The collation URI</xqdoc:param>
    <xqdoc:return>xs:boolean : true() if $suffix is suffix of $source-string, false() otherwise</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>environment-variable</xqdoc:name>
   <xqdoc:signature>environment-variable($name as xs:string) as xs:string?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the value of a system environment variable, if it exists.</xqdoc:description>
    <xqdoc:param>$name Name of environment variable.</xqdoc:param>
    <xqdoc:return>xs:string? : Corrensponding value of the environment variable, if there is no environment variable with a matching name, the function returns the empty sequence. User must be DBA.</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>equals</xqdoc:name>
   <xqdoc:signature>equals($source-string as xs:string?, $substring as xs:string?) as xs:boolean</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:boolean indicating whether or not the value of $source-string  equals the collation units in the value of $substring, according to the default collation. This function is similar to the '=' expression, except that it uses the default collation for comparisons.</xqdoc:description>
    <xqdoc:param>$source-string? The source-string</xqdoc:param>
    <xqdoc:param>$substring? The substring</xqdoc:param>
    <xqdoc:return>xs:boolean : true() if $source-string equals $substring, false() otherwise</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>equals</xqdoc:name>
   <xqdoc:signature>equals($source-string as xs:string?, $substring as xs:string?, $collation-uri as xs:string) as xs:boolean</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:boolean indicating whether or not the value of $source-string equals the  collation units in the value of $substring, according to the collation that is specified in $collation-uri. This function is similar to the '=' expression, except that it uses the specified collation for comparisons.The third argument $collation-uri is either: 1) the full URI e.g. "http://www.w3.org/2013/collation/UCA?lang=en;strength=secondary", or 2) relative where you only need to specify the last part of a valid full collation-uri, e.g. "?lang=sv-SE", "lang=sv-SE;strength=primary;decomposition=standard" or "swedish".</xqdoc:description>
    <xqdoc:param>$source-string? The source-string</xqdoc:param>
    <xqdoc:param>$substring? The substring</xqdoc:param>
    <xqdoc:param>$collation-uri The collation URI</xqdoc:param>
    <xqdoc:return>xs:boolean : true() if $source-string equals $substring, false() otherwise</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>error</xqdoc:name>
   <xqdoc:signature>error() as empty-sequence()</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Indicates that an irrecoverable error has occurred. The script will terminate immediately with an exception using the default qname, 'http://www.w3.org/2004/07/xqt-errors#err:FOER0000', and the default error message, 'An error has been raised by the query'.</xqdoc:description>
    <xqdoc:return>empty-sequence()</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>error</xqdoc:name>
   <xqdoc:signature>error($qname as xs:QName?) as empty-sequence()</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Indicates that an irrecoverable error has occurred. The script will terminate immediately with an exception using $qname and the default message, 'An error has been raised by the query'.</xqdoc:description>
    <xqdoc:param>$qname? The qname</xqdoc:param>
    <xqdoc:return>empty-sequence()</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>error</xqdoc:name>
   <xqdoc:signature>error($qname as xs:QName?, $message as xs:string) as empty-sequence()</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Indicates that an irrecoverable error has occurred. The script will terminate immediately with an exception using $qname and $message.</xqdoc:description>
    <xqdoc:param>$qname? The qname</xqdoc:param>
    <xqdoc:param>$message The message</xqdoc:param>
    <xqdoc:return>empty-sequence()</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>error</xqdoc:name>
   <xqdoc:signature>error($qname as xs:QName?, $message as xs:string, $error-object as item()*) as empty-sequence()</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Indicates that an irrecoverable error has occurred. The script will terminate immediately with an exception using $qname and $message with $error-object appended.</xqdoc:description>
    <xqdoc:param>$qname? The qname</xqdoc:param>
    <xqdoc:param>$message The message</xqdoc:param>
    <xqdoc:param>$error-object* The error object</xqdoc:param>
    <xqdoc:return>empty-sequence()</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>escape-html-uri</xqdoc:name>
   <xqdoc:signature>escape-html-uri($html-uri as xs:string?) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Replaces all non-printable ASCII characters in the string value of $html-uri by an escape sequence represented as a hexadecimal octet in the form %XX. If $html-uri is the empty sequence, returns the zero-length string.</xqdoc:description>
    <xqdoc:param>$html-uri? The html URI</xqdoc:param>
    <xqdoc:return>xs:string : all nonprintable ASCII characters in $html-uri encoded by escape sequences</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>escape-uri</xqdoc:name>
   <xqdoc:signature>escape-uri($uri as xs:string?, $escape-reserved as xs:boolean) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>This function applies the URI escaping rules defined in section 2 of [RFC 2396] as amended by [RFC 2732], with one exception, to the string supplied as $uri, which typically represents all or part of a URI. The effect of the function is to escape a set of identified characters in the string. Each such character is replaced in the string by an escape sequence, which is formed by encoding the character as a sequence of octets in UTF-8, and then representing each of these octets in the form %HH, where HH is the hexadecimal representation of the octet. $escape-reserved indicates whether to escape reserved characters.</xqdoc:description>
    <xqdoc:param>$uri? The URI</xqdoc:param>
    <xqdoc:param>$escape-reserved The escaped-reserved</xqdoc:param>
    <xqdoc:return>xs:string : the identified characters in $uri encoded with escape sequences</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>exactly-one</xqdoc:name>
   <xqdoc:signature>exactly-one($items as item()*) as item()</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the argument sequence, $items, if it contains exactly one item. Otherwise, raises an error.</xqdoc:description>
    <xqdoc:param>$items* The item sequence</xqdoc:param>
    <xqdoc:return>item() : the sole item in $items if it contains exactly one item. Otherwise, an error is raised.</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>exists</xqdoc:name>
   <xqdoc:signature>exists($items as item()*) as xs:boolean</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns true if the argument $items is not the empty sequence, false otherwise.</xqdoc:description>
    <xqdoc:param>$items* The item sequence</xqdoc:param>
    <xqdoc:return>xs:boolean : true() if not the empty-sequence, false() otherwise</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>false</xqdoc:name>
   <xqdoc:signature>false() as xs:boolean</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Always returns the boolean value false</xqdoc:description>
    <xqdoc:return>xs:boolean : false</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>filter</xqdoc:name>
   <xqdoc:signature>filter($sequence as item()*, $function as function(*)) as item()*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns those items from the sequence $sequence for which the supplied function $function returns true.</xqdoc:description>
    <xqdoc:param>$sequence* the sequence to filter</xqdoc:param>
    <xqdoc:param>$function the function to call</xqdoc:param>
    <xqdoc:return>item()* : result of filtering the sequence</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>floor</xqdoc:name>
   <xqdoc:signature>floor($number as xs:numeric?) as xs:numeric?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the largest number not greater than the value of $number. If $number is the empty sequence, returns the empty sequence.</xqdoc:description>
    <xqdoc:param>$number? The number</xqdoc:param>
    <xqdoc:return>xs:numeric? : the largest number without fraction part not greater than the value of $number</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>fold-left</xqdoc:name>
   <xqdoc:signature>fold-left($sequence as item()*, $zero as item()*, $function as function(*)) as item()*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Processes the supplied sequence from left to right, applying the supplied function repeatedly to each item in turn, together with an accumulated result value.</xqdoc:description>
    <xqdoc:param>$sequence* the sequence to filter</xqdoc:param>
    <xqdoc:param>$zero* initial value to start with</xqdoc:param>
    <xqdoc:param>$function the function to call</xqdoc:param>
    <xqdoc:return>item()* : result of the fold-left operation</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>fold-right</xqdoc:name>
   <xqdoc:signature>fold-right($sequence as item()*, $zero as item()*, $function as function(*)) as item()*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Processes the supplied sequence from right to left, applying the supplied function repeatedly to each item in turn, together with an accumulated result value.</xqdoc:description>
    <xqdoc:param>$sequence* the sequence to filter</xqdoc:param>
    <xqdoc:param>$zero* initial value to start with</xqdoc:param>
    <xqdoc:param>$function the function to call</xqdoc:param>
    <xqdoc:return>item()* : result of the fold-right operation</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>for-each</xqdoc:name>
   <xqdoc:signature>for-each($sequence as item()*, $function as function(*)) as item()*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Applies the function item $function to every item from the sequence $sequence in turn, returning the concatenation of the resulting sequences in order.</xqdoc:description>
    <xqdoc:param>$sequence* the sequence on which to apply the function</xqdoc:param>
    <xqdoc:param>$function the function to call</xqdoc:param>
    <xqdoc:return>item()* : result of applying the function to each item of the sequence</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>for-each-pair</xqdoc:name>
   <xqdoc:signature>for-each-pair($seq1 as item()*, $seq2 as item()*, $function as function(*)) as item()*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Applies the function item $f to successive pairs of items taken one from $seq1 and one from $seq2, returning the concatenation of the resulting sequences in order.</xqdoc:description>
    <xqdoc:param>$seq1* first sequence to take items from</xqdoc:param>
    <xqdoc:param>$seq2* second sequence to take items from</xqdoc:param>
    <xqdoc:param>$function the function to call</xqdoc:param>
    <xqdoc:return>item()* : concatenation of resulting sequences</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>format-date</xqdoc:name>
   <xqdoc:signature>format-date($value as xs:date?, $picture as xs:string) as xs:string?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns a string containing an xs:date value formatted for display.</xqdoc:description>
    <xqdoc:param>$value? The date</xqdoc:param>
    <xqdoc:param>$picture The picture string</xqdoc:param>
    <xqdoc:return>xs:string? : The formatted date</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>format-date</xqdoc:name>
   <xqdoc:signature>format-date($value as xs:date?, $picture as xs:string, $language as xs:string?, $calendar as xs:string?, $place as xs:string?) as xs:string?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns a string containing an xs:date value formatted for display.</xqdoc:description>
    <xqdoc:param>$value? The date</xqdoc:param>
    <xqdoc:param>$picture The picture string</xqdoc:param>
    <xqdoc:param>$language? The language string</xqdoc:param>
    <xqdoc:param>$calendar? The calendar string</xqdoc:param>
    <xqdoc:param>$place? The place string</xqdoc:param>
    <xqdoc:return>xs:string? : The formatted date</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>format-dateTime</xqdoc:name>
   <xqdoc:signature>format-dateTime($value as xs:dateTime?, $picture as xs:string) as xs:string?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns a string containing an xs:date value formatted for display.</xqdoc:description>
    <xqdoc:param>$value? The datetime</xqdoc:param>
    <xqdoc:param>$picture The picture string</xqdoc:param>
    <xqdoc:return>xs:string? : The formatted date</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>format-dateTime</xqdoc:name>
   <xqdoc:signature>format-dateTime($value as xs:dateTime?, $picture as xs:string, $language as xs:string?, $calendar as xs:string?, $place as xs:string?) as xs:string?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns a string containing an xs:date value formatted for display.</xqdoc:description>
    <xqdoc:param>$value? The datetime</xqdoc:param>
    <xqdoc:param>$picture The picture string</xqdoc:param>
    <xqdoc:param>$language? The language string</xqdoc:param>
    <xqdoc:param>$calendar? The calendar string</xqdoc:param>
    <xqdoc:param>$place? The place string</xqdoc:param>
    <xqdoc:return>xs:string? : The formatted date</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>format-number</xqdoc:name>
   <xqdoc:signature>format-number($value as xs:numeric?, $picture as xs:string) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>The formatting of a number is controlled by a picture string. The picture string is a sequence of ·characters·, in which the characters assigned to the variables decimal-separator-sign, grouping-sign, decimal-digit-family, optional-digit-sign and pattern-separator-sign are classified as active characters, and all other characters (including the percent-sign and per-mille-sign) are classified as passive characters.</xqdoc:description>
    <xqdoc:param>$value? The number to format</xqdoc:param>
    <xqdoc:param>$picture The format pattern string.  Please see the JavaDoc for java.text.DecimalFormat to get the specifics of this format string.</xqdoc:param>
    <xqdoc:return>xs:string : the formatted string</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>format-number</xqdoc:name>
   <xqdoc:signature>format-number($value as xs:numeric?, $picture as xs:string, $decimal-format-name as xs:string) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description/>
    <xqdoc:param>$value? The number to format</xqdoc:param>
    <xqdoc:param>$picture The format pattern string.  Please see the JavaDoc for java.text.DecimalFormat to get the specifics of this format string.</xqdoc:param>
    <xqdoc:param>$decimal-format-name The decimal-format name must be a QName, which is expanded as described in [2.4 Qualified Names]. It is an error if the stylesheet does not contain a declaration of the decimal-format with the specified expanded-name.</xqdoc:param>
    <xqdoc:return>xs:string : the formatted string</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>format-time</xqdoc:name>
   <xqdoc:signature>format-time($value as xs:time?, $picture as xs:string) as xs:string?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns a string containing an xs:time value formatted for display.</xqdoc:description>
    <xqdoc:param>$value? The time</xqdoc:param>
    <xqdoc:param>$picture The picture string</xqdoc:param>
    <xqdoc:return>xs:string? : The formatted date</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>format-time</xqdoc:name>
   <xqdoc:signature>format-time($value as xs:time?, $picture as xs:string, $language as xs:string?, $calendar as xs:string?, $place as xs:string?) as xs:string?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns a string containing an xs:time value formatted for display.</xqdoc:description>
    <xqdoc:param>$value? The time</xqdoc:param>
    <xqdoc:param>$picture The picture string</xqdoc:param>
    <xqdoc:param>$language? The language string</xqdoc:param>
    <xqdoc:param>$calendar? The calendar string</xqdoc:param>
    <xqdoc:param>$place? The place string</xqdoc:param>
    <xqdoc:return>xs:string? : The formatted date</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>function-arity</xqdoc:name>
   <xqdoc:signature>function-arity($function as function(*)) as xs:integer</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the arity of the function identified by a function item.</xqdoc:description>
    <xqdoc:param>$function The function item</xqdoc:param>
    <xqdoc:return>xs:integer : The arity of the function.</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>function-lookup</xqdoc:name>
   <xqdoc:signature>function-lookup($name as xs:QName, $arity as xs:integer) as function(*)?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns a reference to the function having a given name and arity, if there is one, the empty sequence otherwise</xqdoc:description>
    <xqdoc:param>$name Qualified name of the function</xqdoc:param>
    <xqdoc:param>$arity The arity (number of arguments) of the function</xqdoc:param>
    <xqdoc:return>function(*)? : The function if found, empty sequence otherwise</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>function-name</xqdoc:name>
   <xqdoc:signature>function-name($function as function(*)) as xs:QName?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the name of the function identified by a function item.</xqdoc:description>
    <xqdoc:param>$function The function item</xqdoc:param>
    <xqdoc:return>xs:QName? : The name of the function or the empty sequence if $function is an anonymous function.</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>generate-id</xqdoc:name>
   <xqdoc:signature>generate-id() as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>This function returns a string that uniquely identifies a given node. Without an argument, the node to identify is taken from the current context item.</xqdoc:description>
    <xqdoc:return>xs:string : Unique identifier for the node</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>generate-id</xqdoc:name>
   <xqdoc:signature>generate-id($node as node()?) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>This function returns a string that uniquely identifies a given node.</xqdoc:description>
    <xqdoc:param>$node? The node for which an identifier will be generated. If it is the empty sequence, the result will be the empty string</xqdoc:param>
    <xqdoc:return>xs:string : Unique identifier for the node</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>has-children</xqdoc:name>
   <xqdoc:signature>has-children() as xs:boolean</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns true if the context item has one or more child nodes</xqdoc:description>
    <xqdoc:return>xs:boolean : true if the context item has one of more child nodes, false otherwise</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>has-children</xqdoc:name>
   <xqdoc:signature>has-children($node as node()?) as xs:boolean</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns true if the supplied node has one or more child nodes</xqdoc:description>
    <xqdoc:param>$node? The node to test</xqdoc:param>
    <xqdoc:return>xs:boolean : true if $node has one of more child nodes, false otherwise</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>head</xqdoc:name>
   <xqdoc:signature>head($arg as item()*) as item()?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>The function returns the value of the expression $arg[1], i.e. the first item in the passed in sequence.</xqdoc:description>
    <xqdoc:param>$arg* </xqdoc:param>
    <xqdoc:return>item()? : the first item or the empty sequence</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>hours-from-dateTime</xqdoc:name>
   <xqdoc:signature>hours-from-dateTime($date-time as xs:dateTime?) as xs:integer?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:integer between 0 and 23, both inclusive, representing the value of the hours component in the localized value of $date-time.</xqdoc:description>
    <xqdoc:param>$date-time? The date-time as xs:dateTime</xqdoc:param>
    <xqdoc:return>xs:integer? : the hours component from $date-time</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>hours-from-duration</xqdoc:name>
   <xqdoc:signature>hours-from-duration($duration as xs:duration?) as xs:integer?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:integer representing the hours component in the canonical lexical representation of the value of $duration. The result may be negative.</xqdoc:description>
    <xqdoc:param>$duration? The duration as xs:duration</xqdoc:param>
    <xqdoc:return>xs:integer? : the hours component of $duration</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>hours-from-time</xqdoc:name>
   <xqdoc:signature>hours-from-time($time as xs:time?) as xs:integer?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:integer between 0 and 23, both inclusive, representing the value of the hours component in the localized value of $time.</xqdoc:description>
    <xqdoc:param>$time? The time as xs:time</xqdoc:param>
    <xqdoc:return>xs:integer? : the hours component from $time</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>id</xqdoc:name>
   <xqdoc:signature>id($idrefs as xs:string*) as element()*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the sequence of element nodes that have an ID value matching the value of one or more of the IDREF values supplied in $idrefs. If none is matching or $idrefs is the empty sequence, returns the empty sequence.</xqdoc:description>
    <xqdoc:param>$idrefs* The IDREF sequence</xqdoc:param>
    <xqdoc:return>element()* : the elements with IDs  matching IDREFs from $idref-sequence</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>id</xqdoc:name>
   <xqdoc:signature>id($idrefs as xs:string*, $node-in-document as node()) as element()*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the sequence of element nodes that have an ID value matching the value of one or more of the IDREF values supplied in $idrefs and is in the same document as $node-in-document. If none is matching or $idrefs is the empty sequence, returns the empty sequence.</xqdoc:description>
    <xqdoc:param>$idrefs* The IDREF sequence</xqdoc:param>
    <xqdoc:param>$node-in-document The node in document</xqdoc:param>
    <xqdoc:return>element()* : the elements with IDs matching IDREFs from $idrefs in the same document as $node-in-document</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>idref</xqdoc:name>
   <xqdoc:signature>idref($ids as xs:string*) as node()*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the sequence of element or attributes nodes with an IDREF value matching the value of one or more of the ID values supplied in $ids. If none is matching or $ids is the empty sequence, returns the empty sequence.</xqdoc:description>
    <xqdoc:param>$ids* The ID sequence</xqdoc:param>
    <xqdoc:return>node()* : the elements with matching IDREF values from IDs in $ids</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>idref</xqdoc:name>
   <xqdoc:signature>idref($ids as xs:string*, $node-in-document as node()) as node()*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the sequence of element or attributes nodes with an IDREF value matching the value of one or more of the ID values supplied in $ids. If none is matching or $ids is the empty sequence, returns the empty sequence.</xqdoc:description>
    <xqdoc:param>$ids* The ID sequence</xqdoc:param>
    <xqdoc:param>$node-in-document The node in document</xqdoc:param>
    <xqdoc:return>node()* : the elements with matching IDREF values from IDs in $ids in the same document as $node-in-document</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>implicit-timezone</xqdoc:name>
   <xqdoc:signature>implicit-timezone() as xs:dayTimeDuration</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the value of the implicit timezone property from the dynamic context.</xqdoc:description>
    <xqdoc:return>xs:dayTimeDuration : the implicit timezone daytime-duration from the dynamic context</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>in-scope-prefixes</xqdoc:name>
   <xqdoc:signature>in-scope-prefixes($element as element()) as xs:string*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the prefixes of the in-scope namespaces for $element. For namespaces that have a prefix, it returns the prefix as an xs:NCName. For the default namespace, which has no prefix, it returns the zero-length string.</xqdoc:description>
    <xqdoc:param>$element The element</xqdoc:param>
    <xqdoc:return>xs:string* : the prefixes</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>index-of</xqdoc:name>
   <xqdoc:signature>index-of($source as xs:anyAtomicType*, $search as xs:anyAtomicType) as xs:integer*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns a sequence of positive integers giving the positions within the sequence of atomic values $source that are equal to $search.

The collation used by the invocation of this function is determined according to the rules in 7.3.1 Collations. The collation is used when string comparison is required.

The items in the sequence $source are compared with $search under the rules for the 'eq' operator. Values of type xs:untypedAtomic are compared as if they were of type xs:string. Values that cannot be compared, i.e. the 'eq' operator is not defined for their types, are considered to be distinct. If an item compares equal, then the position of that item in the sequence $source is included in the result.

If the value of $source is the empty sequence, or if no item in $source matches $search, then the empty sequence is returned.

The first item in a sequence is at position 1, not position 0.

The result sequence is in ascending numeric order.</xqdoc:description>
    <xqdoc:param>$source* The source sequence</xqdoc:param>
    <xqdoc:param>$search The search component</xqdoc:param>
    <xqdoc:return>xs:integer* : the sequence of positive integers giving the positions within the sequence</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>index-of</xqdoc:name>
   <xqdoc:signature>index-of($source as xs:anyAtomicType*, $search as xs:anyAtomicType, $collation-uri as xs:string) as xs:integer*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns a sequence of positive integers giving the positions within the sequence of atomic values $source that are equal to $search.

The collation used by the invocation of this function is determined according to the rules in 7.3.1 Collations. The collation is used when string comparison is required.

The items in the sequence $source are compared with $search under the rules for the 'eq' operator. Values of type xs:untypedAtomic are compared as if they were of type xs:string. Values that cannot be compared, i.e. the 'eq' operator is not defined for their types, are considered to be distinct. If an item compares equal, then the position of that item in the sequence $source is included in the result.

If the value of $source is the empty sequence, or if no item in $source matches $search, then the empty sequence is returned.

The first item in a sequence is at position 1, not position 0.

The result sequence is in ascending numeric order. The third argument $collation-uri is either: 1) the full URI e.g. "http://www.w3.org/2013/collation/UCA?lang=en;strength=secondary", or 2) relative where you only need to specify the last part of a valid full collation-uri, e.g. "?lang=sv-SE", "lang=sv-SE;strength=primary;decomposition=standard" or "swedish".</xqdoc:description>
    <xqdoc:param>$source* The source sequence</xqdoc:param>
    <xqdoc:param>$search The search component</xqdoc:param>
    <xqdoc:param>$collation-uri The collation URI</xqdoc:param>
    <xqdoc:return>xs:integer* : the sequence of positive integers giving the positions within the sequence</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>innermost</xqdoc:name>
   <xqdoc:signature>innermost($nodes as node()*) as node()*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns every node within the input sequence that is not an ancestor of another member of the input sequence; the nodes are returned in document order with duplicates eliminated.</xqdoc:description>
    <xqdoc:param>$nodes* The nodes to test</xqdoc:param>
    <xqdoc:return>node()* : The nodes that are not an ancestor of another node in the input sequence</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>insert-before</xqdoc:name>
   <xqdoc:signature>insert-before($target as item()*, $position as xs:integer, $inserts as item()*) as item()*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns a new sequence constructed from the value of $target with the value of $inserts inserted at the position specified by the value of $position. (The value of $target is not affected by the sequence construction.)

If $target is the empty sequence, $inserts is returned. If $inserts is the empty sequence, $target is returned.

The value returned by the function consists of all items of $target whose index is less than $position, followed by all items of $inserts, followed by the remaining elements of $target, in that sequence.

If $position is less than one (1), the first position, the effective value of $position is one (1). If $position is greater than the number of items in $target, then the effective value of $position is equal to the number of items in $target plus 1.</xqdoc:description>
    <xqdoc:param>$target* The target</xqdoc:param>
    <xqdoc:param>$position The position to insert before</xqdoc:param>
    <xqdoc:param>$inserts* The data to insert</xqdoc:param>
    <xqdoc:return>item()* : the new sequence</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>iri-to-uri</xqdoc:name>
   <xqdoc:signature>iri-to-uri($iri as xs:string?) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>This function converts an xs:string containing an IRI into a URI according to the rules spelled out in Section 3.1 of [RFC 3987]. It is idempotent but not invertible.

If $iri contains a character that is invalid in an IRI, such as the space character (see note below), the invalid character is replaced by its percent-encoded form as described in [RFC 3986] before the conversion is performed.

If $iri is the empty sequence, returns the zero-length string.

Since [RFC 3986] recommends that, for consistency, URI producers and normalizers should use uppercase hexadecimal digits for all percent-encodings, this function must always generate hexadecimal values using the upper-case letters A-F.

Notes:

This function does not check whether $iri is a legal IRI. It treats it as an xs:string and operates on the characters in the xs:string.

The following printable ASCII characters are invalid in an IRI: "&lt;", "&gt;", " " " (double quote), space, "{", "}", "|", "\", "^", and "`". Since these characters should not appear in an IRI, if they do appear in $iri they will be percent-encoded. In addition, characters outside the range x20-x126 will be percent-encoded because they are invalid in a URI.

Since this function does not escape the PERCENT SIGN "%" and this character is not allowed in data within a URI, users wishing to convert character strings, such as file names, that include "%" to a URI should manually escape "%" by replacing it with "%25".</xqdoc:description>
    <xqdoc:param>$iri? The IRI</xqdoc:param>
    <xqdoc:return>xs:string : the URI</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>json-doc</xqdoc:name>
   <xqdoc:signature>json-doc($href as xs:string?) as item()?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Reads an external (or database) resource containing JSON, and returns the results of parsing the resource as JSON. An URL parameter without scheme or scheme 'xmldb:' is considered to point to a database resource.</xqdoc:description>
    <xqdoc:param>$href? URL pointing to a JSON resource</xqdoc:param>
    <xqdoc:return>item()? : The parsed data, typically a map, array or atomic value</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>json-doc</xqdoc:name>
   <xqdoc:signature>json-doc($href as xs:string?, $options as map(*)) as item()?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Reads an external (or database) resource containing JSON, and returns the results of parsing the resource as JSON. An URL parameter without scheme or scheme 'xmldb:' is considered to point to a database resource.</xqdoc:description>
    <xqdoc:param>$href? URL pointing to a JSON resource</xqdoc:param>
    <xqdoc:param>$options Parsing options</xqdoc:param>
    <xqdoc:return>item()? : The parsed data, typically a map, array or atomic value</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>lang</xqdoc:name>
   <xqdoc:signature>lang($lang as xs:string?) as xs:boolean</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Tests whether the language of the context item as specified by xml:lang attributes is the same as, or is a sublanguage of, the language specified by $lang. The behavior of the function if the second argument is omitted is exactly the same as if the context item (.) had been passed as the second argument. The language of the argument node, or the context item if the second argument is omitted, is determined by the value of the xml:lang attribute on the node, or, if the node has no such attribute, by the value of the xml:lang attribute on the nearest ancestor of the node that has an xml:lang attribute. If there is no such ancestor, then the function returns false().

The following errors may be raised: if the context item is undefined [err:XPDY0002]XP; if the context item is not a node [err:XPTY0004]XP.

If $lang is the empty sequence it is interpreted as the zero-length string.</xqdoc:description>
    <xqdoc:param>$lang? The language code</xqdoc:param>
    <xqdoc:return>xs:boolean : true if the language code matches, false otherwise</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>lang</xqdoc:name>
   <xqdoc:signature>lang($lang as xs:string?, $node as node()) as xs:boolean</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Tests whether the language of $node as specified by xml:lang attributes is the same as, or is a sublanguage of, the language specified by $lang. The behavior of the function if the second argument is omitted is exactly the same as if the context item (.) had been passed as the second argument. The language of the argument node, or the context item if the second argument is omitted, is determined by the value of the xml:lang attribute on the node, or, if the node has no such attribute, by the value of the xml:lang attribute on the nearest ancestor of the node that has an xml:lang attribute. If there is no such ancestor, then the function returns false().

The following errors may be raised: if the context item is undefined [err:XPDY0002]XP; if the context item is not a node [err:XPTY0004]XP.

If $lang is the empty sequence it is interpreted as the zero-length string.</xqdoc:description>
    <xqdoc:param>$lang? The language code</xqdoc:param>
    <xqdoc:param>$node The node</xqdoc:param>
    <xqdoc:return>xs:boolean : true if the language code matches, false otherwise</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>last</xqdoc:name>
   <xqdoc:signature>last() as xs:integer</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the context size from the dynamic context. If the context item is undefined, an error is raised.</xqdoc:description>
    <xqdoc:return>xs:integer : the context size from the dynamic context</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>load-xquery-module</xqdoc:name>
   <xqdoc:signature>load-xquery-module($module-uri as xs:string) as map(*)</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Provides access to the public functions and global variables of a dynamically-loaded XQuery library module.</xqdoc:description>
    <xqdoc:param>$module-uri The target namespace of the module</xqdoc:param>
    <xqdoc:return>map(*) : a map with two entries: 1) 'variables': a map with one entry for each public global variable declared in the library module. The key of the entry is the name of the variable, as an xs:QName value; the associated value is the value of the variable; 2) 'functions': a map which contains one entry for each public function declared in the library module, except that when two functions have the same name (but different arity), they share the same entry. The key of the entry is the name of the function(s), as an xs:QName value; the associated value is a map A. This map (A) contains one entry for each function with the given name; its key is the arity of the function, as an xs:integer value, and its associated value is the function itself, as a function item. The function can be invoked using the rules for dynamic function invocation.</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>load-xquery-module</xqdoc:name>
   <xqdoc:signature>load-xquery-module($module-uri as xs:string, $options as map(*)) as map(*)</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Provides access to the public functions and global variables of a dynamically-loaded XQuery library module.</xqdoc:description>
    <xqdoc:param>$module-uri The target namespace of the module</xqdoc:param>
    <xqdoc:param>$options Options for loading the module</xqdoc:param>
    <xqdoc:return>map(*) : a map with two entries: 1) 'variables': a map with one entry for each public global variable declared in the library module. The key of the entry is the name of the variable, as an xs:QName value; the associated value is the value of the variable; 2) 'functions': a map which contains one entry for each public function declared in the library module, except that when two functions have the same name (but different arity), they share the same entry. The key of the entry is the name of the function(s), as an xs:QName value; the associated value is a map A. This map (A) contains one entry for each function with the given name; its key is the arity of the function, as an xs:integer value, and its associated value is the function itself, as a function item. The function can be invoked using the rules for dynamic function invocation.</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>local-name</xqdoc:name>
   <xqdoc:signature>local-name() as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the local part of the name of $arg as an xs:string that will either be the zero-length string or will have the lexical form of an xs:NCName.

If the argument is omitted, it defaults to the context item (.). The behavior of the function if the argument is omitted is exactly the same as if the context item had been passed as the argument.

The following errors may be raised: if the context item is undefined [err:XPDY0002]XP; if the context item is not a node [err:XPTY0004]XP.

If the argument is supplied and is the empty sequence, the function returns the zero-length string.

If the target node has no name (that is, if it is a document node, a comment, or a text node), the function returns the zero-length string.

Otherwise, the value returned will be the local part of the expanded-QName of the target node (as determined by the dm:node-name accessor in Section 5.11 node-name AccessorDM. This will be an xs:string whose lexical form is an xs:NCName.</xqdoc:description>
    <xqdoc:return>xs:string : the local name</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>local-name</xqdoc:name>
   <xqdoc:signature>local-name($arg as node()?) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the local part of the name of $arg as an xs:string that will either be the zero-length string or will have the lexical form of an xs:NCName.

If the argument is omitted, it defaults to the context item (.). The behavior of the function if the argument is omitted is exactly the same as if the context item had been passed as the argument.

The following errors may be raised: if the context item is undefined [err:XPDY0002]XP; if the context item is not a node [err:XPTY0004]XP.

If the argument is supplied and is the empty sequence, the function returns the zero-length string.

If the target node has no name (that is, if it is a document node, a comment, or a text node), the function returns the zero-length string.

Otherwise, the value returned will be the local part of the expanded-QName of the target node (as determined by the dm:node-name accessor in Section 5.11 node-name AccessorDM. This will be an xs:string whose lexical form is an xs:NCName.</xqdoc:description>
    <xqdoc:param>$arg? The node to retrieve the local name from</xqdoc:param>
    <xqdoc:return>xs:string : the local name</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>local-name-from-QName</xqdoc:name>
   <xqdoc:signature>local-name-from-QName($arg as xs:QName?) as xs:NCName?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:NCName representing the local part of $arg. If $arg is the empty sequence, returns the empty sequence.</xqdoc:description>
    <xqdoc:param>$arg? The QName</xqdoc:param>
    <xqdoc:return>xs:NCName? : the local name</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>lower-case</xqdoc:name>
   <xqdoc:signature>lower-case($arg as xs:string?) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the value of $arg after translating every character to its lower-case correspondent as defined in the appropriate case mappings section in the Unicode standard. For versions of Unicode beginning with the 2.1.8 update, only locale-insensitive case mappings should be applied. Beginning with version 3.2.0 (and likely future versions) of Unicode, precise mappings are described in default case operations, which are full case mappings in the absence of tailoring for particular languages and environments. Every upper-case character that does not have a lower-case correspondent, as well as every lower-case character, is included in the returned value in its original form.</xqdoc:description>
    <xqdoc:param>$arg? The text to be converted to all lower-case characters</xqdoc:param>
    <xqdoc:return>xs:string : the resulting lower-case text</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>matches</xqdoc:name>
   <xqdoc:signature>matches($input as xs:string?, $pattern as xs:string) as xs:boolean</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>The function returns true if $input matches the regular expression supplied as $pattern, if present; otherwise, it returns false.

If $input is the empty sequence, it is interpreted as the zero-length string.

Unless the metacharacters ^ and $ are used as anchors, the string is considered to match the pattern if any substring matches the pattern. But if anchors are used, the anchors must match the start/end of the string (in string mode), or the start/end of a line (in multiline mode).

Note:

This is different from the behavior of patterns in [XML Schema Part 2: Datatypes Second Edition], where regular expressions are implicitly anchored.

Please note that - in contrast - with the specification - this method allows zero or more items for the string argument.

An error is raised [err:FORX0002] if the value of $pattern is invalid according to the rules described in section 7.6.1 Regular Expression Syntax.

</xqdoc:description>
    <xqdoc:param>$input? The input string</xqdoc:param>
    <xqdoc:param>$pattern The pattern</xqdoc:param>
    <xqdoc:return>xs:boolean : true if the pattern is a match, false otherwise</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>matches</xqdoc:name>
   <xqdoc:signature>matches($input as xs:string?, $pattern as xs:string, $flags as xs:string) as xs:boolean</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>The function returns true if $input matches the regular expression supplied as $pattern as influenced by the value of $flags, if present; otherwise, it returns false.

The effect of calling this version of the function with the $flags argument set to a zero-length string is the same as using the other two argument version. Flags are defined in 7.6.1.1 Flags.

If $input is the empty sequence, it is interpreted as the zero-length string.

Unless the metacharacters ^ and $ are used as anchors, the string is considered to match the pattern if any substring matches the pattern. But if anchors are used, the anchors must match the start/end of the string (in string mode), or the start/end of a line (in multiline mode).

Note:

This is different from the behavior of patterns in [XML Schema Part 2: Datatypes Second Edition], where regular expressions are implicitly anchored.

Please note that - in contrast - with the specification - this method allows zero or more items for the string argument.

An error is raised [err:FORX0002] if the value of $pattern is invalid according to the rules described in section 7.6.1 Regular Expression Syntax.

An error is raised [err:FORX0001] if the value of $flags is invalid according to the rules described in section 7.6.1 Regular Expression Syntax.</xqdoc:description>
    <xqdoc:param>$input? The input string</xqdoc:param>
    <xqdoc:param>$pattern The pattern</xqdoc:param>
    <xqdoc:param>$flags The flags</xqdoc:param>
    <xqdoc:return>xs:boolean : true if the pattern is a match, false otherwise</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>max</xqdoc:name>
   <xqdoc:signature>max($arg as xs:anyAtomicType*) as xs:anyAtomicType?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Selects an item from the input sequence $arg whose value is greater than or equal to the value of every other item in the input sequence. If there are two or more such items, then the specific item whose value is returned is implementation dependent.

The following rules are applied to the input sequence:

- Values of type xs:untypedAtomic in $arg are cast to xs:double.
- Numeric and xs:anyURI values are converted to the least common type that supports the 'ge' operator by a combination of type promotion and subtype substitution. See Section B.1 Type PromotionXP and Section B.2 Operator MappingXP.

The items in the resulting sequence may be reordered in an arbitrary order. The resulting sequence is referred to below as the converted sequence. This function returns an item from the converted sequence rather than the input sequence.

If the converted sequence is empty, the empty sequence is returned.

All items in $arg must be numeric or derived from a single base type for which the 'ge' operator is defined. In addition, the values in the sequence must have a total order. If date/time values do not have a timezone, they are considered to have the implicit timezone provided by the dynamic context for purposes of comparison. Duration values must either all be xs:yearMonthDuration values or must all be xs:dayTimeDuration values.

If any of these conditions is not met, then a type error is raised [err:FORG0006].

If the converted sequence contains the value NaN, the value NaN is returned.

If the items in the value of $arg are of type xs:string or types derived by restriction from xs:string, then the determination of the item with the largest value is made according to the collation that is used.The collation used by the invocation of this function is determined according to the rules in 7.3.1 Collations.</xqdoc:description>
    <xqdoc:param>$arg* The input sequence</xqdoc:param>
    <xqdoc:return>xs:anyAtomicType? : the max value</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>max</xqdoc:name>
   <xqdoc:signature>max($arg as xs:anyAtomicType*, $collation-uri as xs:string) as xs:anyAtomicType?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Selects an item from the input sequence $arg whose value is greater than or equal to the value of every other item in the input sequence. If there are two or more such items, then the specific item whose value is returned is implementation dependent.

The following rules are applied to the input sequence:

- Values of type xs:untypedAtomic in $arg are cast to xs:double.
- Numeric and xs:anyURI values are converted to the least common type that supports the 'ge' operator by a combination of type promotion and subtype substitution. See Section B.1 Type PromotionXP and Section B.2 Operator MappingXP.

The items in the resulting sequence may be reordered in an arbitrary order. The resulting sequence is referred to below as the converted sequence. This function returns an item from the converted sequence rather than the input sequence.

If the converted sequence is empty, the empty sequence is returned.

All items in $arg must be numeric or derived from a single base type for which the 'ge' operator is defined. In addition, the values in the sequence must have a total order. If date/time values do not have a timezone, they are considered to have the implicit timezone provided by the dynamic context for purposes of comparison. Duration values must either all be xs:yearMonthDuration values or must all be xs:dayTimeDuration values.

If any of these conditions is not met, then a type error is raised [err:FORG0006].

If the converted sequence contains the value NaN, the value NaN is returned.

If the items in the value of $arg are of type xs:string or types derived by restriction from xs:string, then the determination of the item with the largest value is made according to the collation that is used.If the type of the items in $arg is not xs:string and $collation-uri is specified, the collation is ignored.

The collation used by the invocation of this function is determined according to the rules in 7.3.1 Collations.</xqdoc:description>
    <xqdoc:param>$arg* The input sequence</xqdoc:param>
    <xqdoc:param>$collation-uri The collation URI</xqdoc:param>
    <xqdoc:return>xs:anyAtomicType? : the max value</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>min</xqdoc:name>
   <xqdoc:signature>min($arg as xs:anyAtomicType*) as xs:anyAtomicType?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Selects an item from the input sequence $arg whose value is less than or equal to the value of every other item in the input sequence. If there are two or more such items, then the specific item whose value is returned is implementation dependent.

The following rules are applied to the input sequence:

- Values of type xs:untypedAtomic in $arg are cast to xs:double.
- Numeric and xs:anyURI values are converted to the least common type that supports the 'le' operator by a combination of type promotion and subtype substitution. See Section B.1 Type PromotionXP and Section B.2 Operator MappingXP.

The items in the resulting sequence may be reordered in an arbitrary order. The resulting sequence is referred to below as the converted sequence. This function returns an item from the converted sequence rather than the input sequence.

If the converted sequence is empty, the empty sequence is returned.

All items in $arg must be numeric or derived from a single base type for which the 'le' operator is defined. In addition, the values in the sequence must have a total order. If date/time values do not have a timezone, they are considered to have the implicit timezone provided by the dynamic context for the purpose of comparison. Duration values must either all be xs:yearMonthDuration values or must all be xs:dayTimeDuration values.

If any of these conditions is not met, a type error is raised [err:FORG0006].

If the converted sequence contains the value NaN, the value NaN is returned.

If the items in the value of $arg are of type xs:string or types derived by restriction from xs:string, then the determination of the item with the smallest value is made according to the collation that is used. The collation used by the invocation of this function is determined according to the rules in 7.3.1 Collations.</xqdoc:description>
    <xqdoc:param>$arg* The input sequence</xqdoc:param>
    <xqdoc:return>xs:anyAtomicType? : the minimum value</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>min</xqdoc:name>
   <xqdoc:signature>min($arg as xs:anyAtomicType*, $collation-uri as xs:string) as xs:anyAtomicType?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Selects an item from the input sequence $arg whose value is less than or equal to the value of every other item in the input sequence. If there are two or more such items, then the specific item whose value is returned is implementation dependent.

The following rules are applied to the input sequence:

- Values of type xs:untypedAtomic in $arg are cast to xs:double.
- Numeric and xs:anyURI values are converted to the least common type that supports the 'le' operator by a combination of type promotion and subtype substitution. See Section B.1 Type PromotionXP and Section B.2 Operator MappingXP.

The items in the resulting sequence may be reordered in an arbitrary order. The resulting sequence is referred to below as the converted sequence. This function returns an item from the converted sequence rather than the input sequence.

If the converted sequence is empty, the empty sequence is returned.

All items in $arg must be numeric or derived from a single base type for which the 'le' operator is defined. In addition, the values in the sequence must have a total order. If date/time values do not have a timezone, they are considered to have the implicit timezone provided by the dynamic context for the purpose of comparison. Duration values must either all be xs:yearMonthDuration values or must all be xs:dayTimeDuration values.

If any of these conditions is not met, a type error is raised [err:FORG0006].

If the converted sequence contains the value NaN, the value NaN is returned.

If the items in the value of $arg are of type xs:string or types derived by restriction from xs:string, then the determination of the item with the smallest value is made according to the collation that is used. If the type of the items in $arg is not xs:string and $collation is specified, the collation is ignored.

The collation used by the invocation of this function is determined according to the rules in 7.3.1 Collations.</xqdoc:description>
    <xqdoc:param>$arg* The input sequence</xqdoc:param>
    <xqdoc:param>$collation-uri The collation URI</xqdoc:param>
    <xqdoc:return>xs:anyAtomicType? : the minimum value</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>minutes-from-dateTime</xqdoc:name>
   <xqdoc:signature>minutes-from-dateTime($date-time as xs:dateTime?) as xs:integer?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:integer value between 0 to 59, both inclusive, representing the value of the minutes component in the localized value of $date-time.</xqdoc:description>
    <xqdoc:param>$date-time? The date-time as xs:dateTime</xqdoc:param>
    <xqdoc:return>xs:integer? : the minutes component from $date-time</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>minutes-from-duration</xqdoc:name>
   <xqdoc:signature>minutes-from-duration($duration as xs:duration?) as xs:integer?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:integer representing the minutes component in the canonical lexical representation of the value of $duration. The result may be negative.</xqdoc:description>
    <xqdoc:param>$duration? The duration as xs:duration</xqdoc:param>
    <xqdoc:return>xs:integer? : the minutes component of $duration</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>minutes-from-time</xqdoc:name>
   <xqdoc:signature>minutes-from-time($time as xs:time?) as xs:integer?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:integer value between 0 to 59, both inclusive, representing the value of the minutes component in the localized value of $time.</xqdoc:description>
    <xqdoc:param>$time? The time as xs:time</xqdoc:param>
    <xqdoc:return>xs:integer? : the minutes component from $time</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>month-from-date</xqdoc:name>
   <xqdoc:signature>month-from-date($date as xs:date?) as xs:integer?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:integer between 1 and 12, both inclusive, representing the month component in the localized value of $date.</xqdoc:description>
    <xqdoc:param>$date? The date as xs:date</xqdoc:param>
    <xqdoc:return>xs:integer? : the month component from $date</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>month-from-dateTime</xqdoc:name>
   <xqdoc:signature>month-from-dateTime($date-time as xs:dateTime?) as xs:integer?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:integer between 1 and 12, both inclusive, representing the month component in the localized value of $date-time.</xqdoc:description>
    <xqdoc:param>$date-time? The date-time as xs:dateTime</xqdoc:param>
    <xqdoc:return>xs:integer? : the month component from $date-time</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>months-from-duration</xqdoc:name>
   <xqdoc:signature>months-from-duration($duration as xs:duration?) as xs:integer?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:integer representing the months component in the canonical lexical representation of the value of $duration. The result may be negative.</xqdoc:description>
    <xqdoc:param>$duration? The duration as xs:duration</xqdoc:param>
    <xqdoc:return>xs:integer? : the months component of $duration</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>name</xqdoc:name>
   <xqdoc:signature>name() as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the name of the context item as an xs:string that is either the zero-length string, or has the lexical form of an xs:QName.

The behavior of the function if the argument is omitted is exactly the same as if the context item had been passed as the argument.

The following errors may be raised: if the context item is undefined [err:XPDY0002]XP; if the context item is not a node [err:XPTY0004]XP.

If the argument is supplied and is the empty sequence, the function returns the zero-length string.

If the target node has no name (that is, if it is a document node, a comment, a text node, or a namespace binding having no name), the function returns the zero-length string.

Otherwise, the value returned is fn:string(fn:node-name($arg)).</xqdoc:description>
    <xqdoc:return>xs:string : the name</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>name</xqdoc:name>
   <xqdoc:signature>name($arg as node()?) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the name of $arg as an xs:string that is either the zero-length string, or has the lexical form of an xs:QName.

If the argument is omitted, it defaults to the context item (.). The behavior of the function if the argument is omitted is exactly the same as if the context item had been passed as the argument.

The following errors may be raised: if the context item is undefined [err:XPDY0002]XP; if the context item is not a node [err:XPTY0004]XP.

If the argument is supplied and is the empty sequence, the function returns the zero-length string.

If the target node has no name (that is, if it is a document node, a comment, a text node, or a namespace binding having no name), the function returns the zero-length string.

Otherwise, the value returned is fn:string(fn:node-name($arg)).</xqdoc:description>
    <xqdoc:param>$arg? The input node</xqdoc:param>
    <xqdoc:return>xs:string : the name</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>namespace-uri</xqdoc:name>
   <xqdoc:signature>namespace-uri() as xs:anyURI</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the namespace URI of the xs:QName of the context item.

The behavior of the function if the argument is omitted is exactly the same as if the context item had been passed as the argument.

The following errors may be raised: if the context item is undefined [err:XPDY0002]XP; if the context item is not a node [err:XPTY0004]XP.

If $arg is neither an element nor an attribute node, or if it is an element or attribute node whose expanded-QName (as determined by the dm:node-name accessor in the Section 5.11 node-name AccessorDM) is in no namespace, then the function returns the xs:anyURI corresponding to the zero-length string.</xqdoc:description>
    <xqdoc:return>xs:anyURI : the namespace URI</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>namespace-uri</xqdoc:name>
   <xqdoc:signature>namespace-uri($arg as node()?) as xs:anyURI</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the namespace URI of the xs:QName of $arg.

If the argument is omitted, it defaults to the context node (.). The behavior of the function if the argument is omitted is exactly the same as if the context item had been passed as the argument.

The following errors may be raised: if the context item is undefined [err:XPDY0002]XP; if the context item is not a node [err:XPTY0004]XP.

If $arg is neither an element nor an attribute node, or if it is an element or attribute node whose expanded-QName (as determined by the dm:node-name accessor in the Section 5.11 node-name AccessorDM) is in no namespace, then the function returns the xs:anyURI corresponding to the zero-length string.</xqdoc:description>
    <xqdoc:param>$arg? The input node</xqdoc:param>
    <xqdoc:return>xs:anyURI : the namespace URI</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>namespace-uri-for-prefix</xqdoc:name>
   <xqdoc:signature>namespace-uri-for-prefix($prefix as xs:string?, $element as element()) as xs:anyURI?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the namespace URI of one of the in-scope namespaces for $element, identified by its namespace prefix.

If $element has an in-scope namespace whose namespace prefix is equal to $prefix, it returns the namespace URI of that namespace. If $prefix is the zero-length string or the empty sequence, it returns the namespace URI of the default (unnamed) namespace. Otherwise, it returns the empty sequence.

Prefixes are equal only if their Unicode code points match exactly.</xqdoc:description>
    <xqdoc:param>$prefix? The namespace prefix</xqdoc:param>
    <xqdoc:param>$element The element</xqdoc:param>
    <xqdoc:return>xs:anyURI? : the namespace URI</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>namespace-uri-from-QName</xqdoc:name>
   <xqdoc:signature>namespace-uri-from-QName($arg as xs:QName?) as xs:anyURI?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the namespace URI for $arg. If $arg is the empty sequence, returns the empty sequence.</xqdoc:description>
    <xqdoc:param>$arg? The QName</xqdoc:param>
    <xqdoc:return>xs:anyURI? : the namespace URI</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>nilled</xqdoc:name>
   <xqdoc:signature>nilled($arg as node()?) as xs:boolean?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:boolean indicating whether the argument node is "nilled". If the argument is not an element node, returns the empty sequence. If the argument is the empty sequence, returns the empty sequence.</xqdoc:description>
    <xqdoc:param>$arg? The input node</xqdoc:param>
    <xqdoc:return>xs:boolean? : true if the argument node is "nilled"</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>node-name</xqdoc:name>
   <xqdoc:signature>node-name() as xs:QName?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an expanded-QName for node kinds that can have names. For other kinds of nodes it returns the empty sequence. If the context item is the empty sequence, the empty sequence is returned.</xqdoc:description>
    <xqdoc:return>xs:QName? : the expanded QName</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>node-name</xqdoc:name>
   <xqdoc:signature>node-name($arg as node()?) as xs:QName?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an expanded-QName for node kinds that can have names. For other kinds of nodes it returns the empty sequence. If $arg is the empty sequence, the empty sequence is returned.</xqdoc:description>
    <xqdoc:param>$arg? The input node</xqdoc:param>
    <xqdoc:return>xs:QName? : the expanded QName</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>normalize-space</xqdoc:name>
   <xqdoc:signature>normalize-space() as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the calculated string value of the context item with whitespace normalized by stripping leading and trailing whitespace and replacing sequences of one or more than one whitespace character with a single space, #x20.

The whitespace characters are defined in the metasymbol S (Production 3) of [Extensible Markup Language (XML) 1.0 Recommendation (Third Edition)].

Note:

The definition of the metasymbol S (Production 3), is unchanged in [Extensible Markup Language (XML) 1.1 Recommendation].

If no argument is supplied, $arg defaults to the string value (calculated using fn:string()) of the context item (.). If no argument is supplied or if the argument is the context item and the context item is undefined an error is raised: [err:XPDY0002].</xqdoc:description>
    <xqdoc:return>xs:string : the normalized text</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>normalize-space</xqdoc:name>
   <xqdoc:signature>normalize-space($arg as xs:string?) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the value of $arg with whitespace normalized by stripping leading and trailing whitespace and replacing sequences of one or more than one whitespace character with a single space, #x20.

The whitespace characters are defined in the metasymbol S (Production 3) of [Extensible Markup Language (XML) 1.0 Recommendation (Third Edition)].

Note:

The definition of the metasymbol S (Production 3), is unchanged in [Extensible Markup Language (XML) 1.1 Recommendation].

If the value of $arg is the empty sequence, returns the zero-length string.

If no argument is supplied, $arg defaults to the string value (calculated using fn:string()) of the context item (.). If no argument is supplied or if the argument is the context item and the context item is undefined an error is raised: [err:XPDY0002].</xqdoc:description>
    <xqdoc:param>$arg? The string to normalize</xqdoc:param>
    <xqdoc:return>xs:string : the normalized text</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>normalize-unicode</xqdoc:name>
   <xqdoc:signature>normalize-unicode($arg as xs:string?) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the value of the context item normalized according to the nomalization form "NFC"

</xqdoc:description>
    <xqdoc:param>$arg? The unicode string to normalize</xqdoc:param>
    <xqdoc:return>xs:string : the normalized text</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>normalize-unicode</xqdoc:name>
   <xqdoc:signature>normalize-unicode($arg as xs:string?, $normalization-form as xs:string) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the value of $arg normalized according to the normalization criteria for a normalization form identified by the value of $normalization-form. The effective value of the $normalization-form is computed by removing leading and trailing blanks, if present, and converting to upper case.

If the value of $arg is the empty sequence, returns the zero-length string.

See [Character Model for the World Wide Web 1.0: Normalization] for a description of the normalization forms.

- If the effective value of $normalization-form is "NFC", then the value returned by the function is the value of $arg in Unicode Normalization Form C (NFC).
- If the effective value of $normalization-form is "NFD", then the value returned by the function is the value of $arg in Unicode Normalization Form D (NFD).
- If the effective value of $normalization-form is "NFKC", then the value returned by the function is the value of $arg in Unicode Normalization Form KC (NFKC).
- If the effective value of $normalization-form is "NFKD", then the value returned by the function is the value of $arg in Unicode Normalization Form KD (NFKD).
- If the effective value of $normalization-form is "FULLY-NORMALIZED", then the value returned by the function is the value of $arg in the fully normalized form.
- If the effective value of $normalization-form is the zero-length string, no normalization is performed and $arg is returned.

Conforming implementations must support normalization form "NFC" and may support normalization forms "NFD", "NFKC", "NFKD", "FULLY-NORMALIZED". They may also support other normalization forms with implementation-defined semantics. If the effective value of the $normalization-form is other than one of the values supported by the implementation, then an error is raised [err:FOCH0003].</xqdoc:description>
    <xqdoc:param>$arg? The unicode string to normalize</xqdoc:param>
    <xqdoc:param>$normalization-form The normalization form</xqdoc:param>
    <xqdoc:return>xs:string : the normalized text</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>not</xqdoc:name>
   <xqdoc:signature>not($arg as item()*) as xs:boolean</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description> Returns true if the effective boolean value is false, and false if the effective boolean value is true. 

 $arg is reduced to an effective boolean value by applying the fn:boolean() function.</xqdoc:description>
    <xqdoc:param>$arg* The input items</xqdoc:param>
    <xqdoc:return>xs:boolean : the negated effective boolean value (ebv) of $arg</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>number</xqdoc:name>
   <xqdoc:signature>number() as xs:double</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the value of the context item after atomization, converted to an xs:double.

If the context item cannot be converted to an xs:double, the xs:double value NaN is returned. If the context item is undefined an error is raised: [err:XPDY0002]XP.

</xqdoc:description>
    <xqdoc:return>xs:double : the numerical value</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>number</xqdoc:name>
   <xqdoc:signature>number($arg as xs:anyAtomicType?) as xs:double</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the value indicated by $arg or, if $arg is not specified, the context item after atomization, converted to an xs:double.

Calling the zero-argument version of the function is defined to give the same result as calling the single-argument version with the context item (.). That is, fn:number() is equivalent to fn:number(.).

If $arg is the empty sequence or if $arg or the context item cannot be converted to an xs:double, the xs:double value NaN is returned. If the context item is undefined an error is raised: [err:XPDY0002]XP.

If $arg is the empty sequence, NaN is returned. Otherwise, $arg, or the context item after atomization, is converted to an xs:double following the rules of 17.1.3.2 Casting to xs:double. If the conversion to xs:double fails, the xs:double value NaN is returned.</xqdoc:description>
    <xqdoc:param>$arg? The input item</xqdoc:param>
    <xqdoc:return>xs:double : the numerical value</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>one-or-more</xqdoc:name>
   <xqdoc:signature>one-or-more($arg as item()*) as item()+</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns $arg if it contains one or more items. Otherwise, raises an error.</xqdoc:description>
    <xqdoc:param>$arg* The input sequence</xqdoc:param>
    <xqdoc:return>item()+ : the sequence passed in by $arg if it contains one or more items.</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>outermost</xqdoc:name>
   <xqdoc:signature>outermost($nodes as node()*) as node()*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns every node within the input sequence that has no ancestor that is itself a member of the input sequence; the nodes are returned in document order with duplicates eliminated.</xqdoc:description>
    <xqdoc:param>$nodes* The nodes to test</xqdoc:param>
    <xqdoc:return>node()* : The nodes that have no ancestor which is itself in the input sequence</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>parse-json</xqdoc:name>
   <xqdoc:signature>parse-json($json-text as xs:string?) as item()?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Parses a string supplied in the form of a JSON text, returning the results typically in the form of a map or array.</xqdoc:description>
    <xqdoc:param>$json-text? JSON string</xqdoc:param>
    <xqdoc:return>item()? : The parsed data, typically a map, array or atomic value</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>parse-json</xqdoc:name>
   <xqdoc:signature>parse-json($json-text as xs:string?, $options as map(*)) as item()?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Parses a string supplied in the form of a JSON text, returning the results typically in the form of a map or array.</xqdoc:description>
    <xqdoc:param>$json-text? JSON string</xqdoc:param>
    <xqdoc:param>$options Parsing options</xqdoc:param>
    <xqdoc:return>item()? : The parsed data, typically a map, array or atomic value</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>parse-xml</xqdoc:name>
   <xqdoc:signature>parse-xml($arg as xs:string?) as document-node()?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>This function takes as input an XML document represented as a string, and returns the document node at the root of an XDM tree representing the parsed document.</xqdoc:description>
    <xqdoc:param>$arg? The string to be parsed</xqdoc:param>
    <xqdoc:return>document-node()? : the parsed document</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>parse-xml-fragment</xqdoc:name>
   <xqdoc:signature>parse-xml-fragment($arg as xs:string?) as document-node()?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>This function takes as input an XML external entity represented as a string,and returns the document node at the root of an XDM tree representing the parsed document fragment.</xqdoc:description>
    <xqdoc:param>$arg? The string to be parsed</xqdoc:param>
    <xqdoc:return>document-node()? : the parsed document fragment</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>position</xqdoc:name>
   <xqdoc:signature>position() as xs:integer</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the context position from the dynamic context. If the context item is undefined, raises an error.</xqdoc:description>
    <xqdoc:return>xs:integer : the context position</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>prefix-from-QName</xqdoc:name>
   <xqdoc:signature>prefix-from-QName($arg as xs:QName?) as xs:NCName?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:NCName representing the prefix of $arg. If $arg is the empty sequence, returns the empty sequence.</xqdoc:description>
    <xqdoc:param>$arg? The QName</xqdoc:param>
    <xqdoc:return>xs:NCName? : the prefix</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>remove</xqdoc:name>
   <xqdoc:signature>remove($target as item()*, $position as xs:integer) as item()*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns a new sequence constructed from the value of $target with the item at $position removed.

If $position is less than 1 or greater than the number of items in $target, $target is returned. Otherwise, the value returned by the function consists of all items of $target whose index is less than $position, followed by all items of $target whose index is greater than $position. If $target is the empty sequence, the empty sequence is returned.</xqdoc:description>
    <xqdoc:param>$target* The input sequence</xqdoc:param>
    <xqdoc:param>$position The position of the value to be removed</xqdoc:param>
    <xqdoc:return>item()* : the new sequence with the item at the position specified by the value of $position removed.</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>replace</xqdoc:name>
   <xqdoc:signature>replace($input as xs:string?, $pattern as xs:string, $replacement as xs:string) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>The function returns the xs:string that is obtained by replacing each non-overlapping substring of $input that matches the given $pattern with an occurrence of the $replacement string.

If $input is the empty sequence, it is interpreted as the zero-length string.

If two overlapping substrings of $input both match the $pattern, then only the first one (that is, the one whose first character comes first in the $input string) is replaced.

Within the $replacement string, a variable $N may be used to refer to the substring captured by the Nth parenthesized sub-expression in the regular expression. For each match of the pattern, these variables are assigned the value of the content matched by the relevant sub-expression, and the modified replacement string is then substituted for the characters in $input that matched the pattern. $0 refers to the substring captured by the regular expression as a whole.

More specifically, the rules are as follows, where S is the number of parenthesized sub-expressions in the regular expression, and N is the decimal number formed by taking all the digits that consecutively follow the $ character:

1.  If N=0, then the variable is replaced by the substring matched by the regular expression as a whole.

2.  If 1&lt;=N&lt;=S, then the variable is replaced by the substring captured by the Nth parenthesized sub-expression. If the Nth parenthesized sub-expression was not matched, then the variable is replaced by the zero-length string.

3.  If S&lt;N&lt;=9, then the variable is replaced by the zero-length string.

4.  Otherwise (if N&gt;S and N&gt;9), the last digit of N is taken to be a literal character to be included "as is" in the replacement string, and the rules are reapplied using the number N formed by stripping off this last digit.</xqdoc:description>
    <xqdoc:param>$input? The input string</xqdoc:param>
    <xqdoc:param>$pattern The pattern to match</xqdoc:param>
    <xqdoc:param>$replacement The string to replace the pattern with</xqdoc:param>
    <xqdoc:return>xs:string : the altered string</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>replace</xqdoc:name>
   <xqdoc:signature>replace($input as xs:string?, $pattern as xs:string, $replacement as xs:string, $flags as xs:string) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>The function returns the xs:string that is obtained by replacing each non-overlapping substring of $input that matches the given $pattern with an occurrence of the $replacement string.

The $flags argument is interpreted in the same manner as for the fn:matches() function.

Calling the four argument version with the $flags argument set to a zero-length string gives the same effect as using the three argument version.

If $input is the empty sequence, it is interpreted as the zero-length string.

If two overlapping substrings of $input both match the $pattern, then only the first one (that is, the one whose first character comes first in the $input string) is replaced.

Within the $replacement string, a variable $N may be used to refer to the substring captured by the Nth parenthesized sub-expression in the regular expression. For each match of the pattern, these variables are assigned the value of the content matched by the relevant sub-expression, and the modified replacement string is then substituted for the characters in $input that matched the pattern. $0 refers to the substring captured by the regular expression as a whole.

More specifically, the rules are as follows, where S is the number of parenthesized sub-expressions in the regular expression, and N is the decimal number formed by taking all the digits that consecutively follow the $ character:

1.  If N=0, then the variable is replaced by the substring matched by the regular expression as a whole.

2.  If 1&lt;=N&lt;=S, then the variable is replaced by the substring captured by the Nth parenthesized sub-expression. If the Nth parenthesized sub-expression was not matched, then the variable is replaced by the zero-length string.

3.  If S&lt;N&lt;=9, then the variable is replaced by the zero-length string.

4.  Otherwise (if N&gt;S and N&gt;9), the last digit of N is taken to be a literal character to be included "as is" in the replacement string, and the rules are reapplied using the number N formed by stripping off this last digit.</xqdoc:description>
    <xqdoc:param>$input? The input string</xqdoc:param>
    <xqdoc:param>$pattern The pattern to match</xqdoc:param>
    <xqdoc:param>$replacement The string to replace the pattern with</xqdoc:param>
    <xqdoc:param>$flags The flags</xqdoc:param>
    <xqdoc:return>xs:string : the altered string</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>resolve-QName</xqdoc:name>
   <xqdoc:signature>resolve-QName($qname as xs:string?, $element as element()) as xs:QName?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:QName value (that is, an expanded-QName) by taking an xs:string that has the lexical form of an xs:QName (a string in the form "prefix:local-name" or "local-name") and resolving it using the in-scope namespaces for a given element.

If $qname does not have the correct lexical form for xs:QName an error is raised [err:FOCA0002].

If $qname is the empty sequence, returns the empty sequence.

More specifically, the function searches the namespace bindings of $element for a binding whose name matches the prefix of $qname, or the zero-length string if it has no prefix, and constructs an expanded-QName whose local name is taken from the supplied $qname, and whose namespace URI is taken from the string value of the namespace binding.

If the $qname has a prefix and if there is no namespace binding for $element that matches this prefix, then an error is raised [err:FONS0004].

If the $qname has no prefix, and there is no namespace binding for $element corresponding to the default (unnamed) namespace, then the resulting expanded-QName has no namespace part.

The prefix (or absence of a prefix) in the supplied $qname argument is retained in the returned expanded-QName.</xqdoc:description>
    <xqdoc:param>$qname? The QName name</xqdoc:param>
    <xqdoc:param>$element The element</xqdoc:param>
    <xqdoc:return>xs:QName? : the QName of $element with lexical form $qname</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>resolve-uri</xqdoc:name>
   <xqdoc:signature>resolve-uri($relative as xs:string?) as xs:anyURI?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Resolves $relative against the value of the base-uri property from the static context using an algorithm such as the ones described in [RFC 2396] or [RFC 3986], and the resulting absolute URI reference is returned. An error may be raised [err:FORG0009] in the resolution process.

If $relative is an absolute URI reference, it is returned unchanged.

If $relative or $base is not a valid xs:anyURI an error is raised [err:FORG0002].

If $relative is the empty sequence, the empty sequence is returned.</xqdoc:description>
    <xqdoc:param>$relative? The relative URI</xqdoc:param>
    <xqdoc:return>xs:anyURI? : the absolute URI</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>resolve-uri</xqdoc:name>
   <xqdoc:signature>resolve-uri($relative as xs:string?, $base as xs:string) as xs:anyURI?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Resolves $relative against $base using an algorithm such as the ones described in [RFC 2396] or [RFC 3986], and the resulting absolute URI reference is returned. An error may be raised [err:FORG0009] in the resolution process.

If $relative is an absolute URI reference, it is returned unchanged.

If $relative or $base is not a valid xs:anyURI an error is raised [err:FORG0002].

If $relative is the empty sequence, the empty sequence is returned.</xqdoc:description>
    <xqdoc:param>$relative? The relative URI</xqdoc:param>
    <xqdoc:param>$base The base URI</xqdoc:param>
    <xqdoc:return>xs:anyURI? : the absolute URI</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>reverse</xqdoc:name>
   <xqdoc:signature>reverse($arg as item()*) as item()*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Reverses the order of items in a sequence.  If the argument is an emptysequence, the empty sequence is returned.</xqdoc:description>
    <xqdoc:param>$arg* The sequence to reverse</xqdoc:param>
    <xqdoc:return>item()* : the reverse order sequence</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>root</xqdoc:name>
   <xqdoc:signature>root() as node()</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the root of the tree to which the context item belongs. </xqdoc:description>
    <xqdoc:return>node() : the root node of the tree to which the context node belongs</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>root</xqdoc:name>
   <xqdoc:signature>root($arg as node()?) as node()?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the root of the tree to which $arg belongs. This will usually, but not necessarily, be a document node.

If $arg is the empty sequence, the empty sequence is returned.

If $arg is a document node, $arg is returned.

 The behavior of the zero argument version of the function is exactly the same as if the context item had been passed in $arg.</xqdoc:description>
    <xqdoc:param>$arg? The input node</xqdoc:param>
    <xqdoc:return>node()? : the root node of the tree to which $arg belongs</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>round</xqdoc:name>
   <xqdoc:signature>round($arg as xs:numeric?) as xs:numeric?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the number with no fractional part that is closest to the argument $arg. If there are two such numbers, then the one that is closest to positive infinity is returned. If type of $arg is one of the four numeric types xs:float, xs:double, xs:decimal or xs:integer the type of the result is the same as the type of $arg. If the type of $arg is a type derived from one of the numeric types, the result is an instance of the base numeric type.

For xs:float and xs:double arguments, if the argument is positive infinity, then positive infinity is returned. If the argument is negative infinity, then negative infinity is returned. If the argument is positive zero, then positive zero is returned. If the argument is negative zero, then negative zero is returned. If the argument is less than zero, but greater than or equal to -0.5, then negative zero is returned. In the cases where positive zero or negative zero is returned, negative zero or positive zero may be returned as [XML Schema Part 2: Datatypes Second Edition] does not distinguish between the values positive zero and negative zero.</xqdoc:description>
    <xqdoc:param>$arg? The input number</xqdoc:param>
    <xqdoc:return>xs:numeric? : the rounded value</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>round-half-to-even</xqdoc:name>
   <xqdoc:signature>round-half-to-even($arg as xs:numeric?) as xs:numeric?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>The value returned is the nearest (that is, numerically closest) value to $arg that is a multiple of ten to the power of minus 0. If two such values are equally near (e.g. if the fractional part in $arg is exactly .500...), the function returns the one whose least significant digit is even.

If the type of $arg is one of the four numeric types xs:float, xs:double, xs:decimal or xs:integer the type of the result is the same as the type of $arg. If the type of $arg is a type derived from one of the numeric types, the result is an instance of the base numeric type.

The three argument version of the function with $precision = 0 produces the same result as the two argument version.

For arguments of type xs:float and xs:double, if the argument is NaN, positive or negative zero, or positive or negative infinity, then the result is the same as the argument. In all other cases, the argument is cast to xs:decimal, the function is applied to this xs:decimal value, and the resulting xs:decimal is cast back to xs:float or xs:double as appropriate to form the function result. If the resulting xs:decimal value is zero, then positive or negative zero is returned according to the sign of the original argument.

Note that the process of casting to xs:decimal may result in an error [err:FOCA0001].

If $arg is of type xs:float or xs:double, rounding occurs on the value of the mantissa computed with exponent = 0.</xqdoc:description>
    <xqdoc:param>$arg? The input number</xqdoc:param>
    <xqdoc:return>xs:numeric? : the rounded value</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>round-half-to-even</xqdoc:name>
   <xqdoc:signature>round-half-to-even($arg as xs:numeric?, $precision as xs:integer) as xs:numeric?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>The value returned is the nearest (that is, numerically closest) value to $arg that is a multiple of ten to the power of minus $precision. If two such values are equally near (e.g. if the fractional part in $arg is exactly .500...), the function returns the one whose least significant digit is even.

If the type of $arg is one of the four numeric types xs:float, xs:double, xs:decimal or xs:integer the type of the result is the same as the type of $arg. If the type of $arg is a type derived from one of the numeric types, the result is an instance of the base numeric type.

The three argument version of the function with $precision = 0 produces the same result as the two argument version.

For arguments of type xs:float and xs:double, if the argument is NaN, positive or negative zero, or positive or negative infinity, then the result is the same as the argument. In all other cases, the argument is cast to xs:decimal, the function is applied to this xs:decimal value, and the resulting xs:decimal is cast back to xs:float or xs:double as appropriate to form the function result. If the resulting xs:decimal value is zero, then positive or negative zero is returned according to the sign of the original argument.

Note that the process of casting to xs:decimal may result in an error [err:FOCA0001].

If $arg is of type xs:float or xs:double, rounding occurs on the value of the mantissa computed with exponent = 0.</xqdoc:description>
    <xqdoc:param>$arg? The input number</xqdoc:param>
    <xqdoc:param>$precision The precision factor</xqdoc:param>
    <xqdoc:return>xs:numeric? : the rounded value</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>seconds-from-dateTime</xqdoc:name>
   <xqdoc:signature>seconds-from-dateTime($date-time as xs:dateTime?) as xs:decimal?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:decimal value between 0 and 60.999..., both inclusive, representing the seconds and fractional seconds in the localized value of $date-time. Note that the value can be greater than 60 seconds to accommodate occasional leap seconds used to keep human time synchronized with the rotation of the planet.</xqdoc:description>
    <xqdoc:param>$date-time? The date-time as xs:dateTime</xqdoc:param>
    <xqdoc:return>xs:decimal? : the seconds component from $date-time</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>seconds-from-duration</xqdoc:name>
   <xqdoc:signature>seconds-from-duration($duration as xs:duration?) as xs:decimal?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:decimal representing the seconds component in the canonical lexical representation of the value of $duration. The result may be negative</xqdoc:description>
    <xqdoc:param>$duration? The duration as xs:duration</xqdoc:param>
    <xqdoc:return>xs:decimal? : the seconds component of $duration</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>seconds-from-time</xqdoc:name>
   <xqdoc:signature>seconds-from-time($time as xs:time?) as xs:decimal?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:decimal value between 0 and 60.999..., both inclusive, representing the seconds and fractional seconds in the localized value of $date. Note that the value can be greater than 60 seconds to accommodate occasional leap seconds used to keep human time synchronized with the rotation of the planet.</xqdoc:description>
    <xqdoc:param>$time? The time as xs:time</xqdoc:param>
    <xqdoc:return>xs:decimal? : the seconds component from $time</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>serialize</xqdoc:name>
   <xqdoc:signature>serialize($args as item()*) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>This function serializes the supplied input sequence $arg as described in XSLT and XQuery Serialization 3.0, returning the serialized representation of the sequence as a string.</xqdoc:description>
    <xqdoc:param>$args* The node set to serialize</xqdoc:param>
    <xqdoc:return>xs:string : the string containing the serialized node set.</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>serialize</xqdoc:name>
   <xqdoc:signature>serialize($args as item()*, $parameters as item()?) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>This function serializes the supplied input sequence $arg as described in XSLT and XQuery Serialization 3.0, returning the serialized representation of the sequence as a string.</xqdoc:description>
    <xqdoc:param>$args* The node set to serialize</xqdoc:param>
    <xqdoc:param>$parameters? The serialization parameters as either a output:serialization-parameters element or a map</xqdoc:param>
    <xqdoc:return>xs:string : the string containing the serialized node set.</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>sort</xqdoc:name>
   <xqdoc:signature>sort($input as item()*) as item()*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Sorts a supplied sequence.</xqdoc:description>
    <xqdoc:param>$input* </xqdoc:param>
    <xqdoc:return>item()* : the first item or the empty sequence</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>sort</xqdoc:name>
   <xqdoc:signature>sort($input as item()*, $collation as xs:string?) as item()*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Sorts a supplied sequence, based on the value of a sort key supplied as a function.</xqdoc:description>
    <xqdoc:param>$input* </xqdoc:param>
    <xqdoc:param>$collation? </xqdoc:param>
    <xqdoc:return>item()* : the resulting sequence</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>sort</xqdoc:name>
   <xqdoc:signature>sort($input as item()*, $collation as xs:string?, $key as function(*)) as item()*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Sorts a supplied sequence, based on the value of a sort key supplied as a function.</xqdoc:description>
    <xqdoc:param>$input* </xqdoc:param>
    <xqdoc:param>$collation? </xqdoc:param>
    <xqdoc:param>$key </xqdoc:param>
    <xqdoc:return>item()* : the resulting sequence</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>starts-with</xqdoc:name>
   <xqdoc:signature>starts-with($source as xs:string?, $prefix as xs:string?) as xs:boolean</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:boolean indicating whether or not the value of $source starts with a sequence of collation units that provides a minimal match to the collation units of $prefix according to the collation that is used.

Note:

"Minimal match" is defined in [Unicode Collation Algorithm].

If the value of $source or $prefix is the empty sequence, or contains only ignorable collation units, it is interpreted as the zero-length string.

If the value of $prefix is the zero-length string, then the function returns true. If the value of $source is the zero-length string and the value of $prefix is not the zero-length string, then the function returns false.

The collation used by the invocation of this function is determined according to the rules in 7.3.1 Collations. If the specified collation does not support collation units an error may be raised [err:FOCH0004]. </xqdoc:description>
    <xqdoc:param>$source? The source string</xqdoc:param>
    <xqdoc:param>$prefix? The string to determine if is a prefix of $source</xqdoc:param>
    <xqdoc:return>xs:boolean : true if $prefix is a prefix of the string $source</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>starts-with</xqdoc:name>
   <xqdoc:signature>starts-with($source as xs:string?, $prefix as xs:string?, $collation-uri as xs:string) as xs:boolean</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:boolean indicating whether or not the value of $source starts with a sequence of collation units that provides a minimal match to the collation units of $prefix according to the collation that is used.

Note:

"Minimal match" is defined in [Unicode Collation Algorithm].

If the value of $source or $prefix is the empty sequence, or contains only ignorable collation units, it is interpreted as the zero-length string.

If the value of $prefix is the zero-length string, then the function returns true. If the value of $source is the zero-length string and the value of $prefix is not the zero-length string, then the function returns false.

The collation used by the invocation of this function is determined according to the rules in 7.3.1 Collations. If the specified collation does not support collation units an error may be raised [err:FOCH0004]. The third argument $collation-uri is either: 1) the full URI e.g. "http://www.w3.org/2013/collation/UCA?lang=en;strength=secondary", or 2) relative where you only need to specify the last part of a valid full collation-uri, e.g. "?lang=sv-SE", "lang=sv-SE;strength=primary;decomposition=standard" or "swedish".</xqdoc:description>
    <xqdoc:param>$source? The source string</xqdoc:param>
    <xqdoc:param>$prefix? The string to determine if is a prefix of $source</xqdoc:param>
    <xqdoc:param>$collation-uri The collation URI</xqdoc:param>
    <xqdoc:return>xs:boolean : true if $prefix is a prefix of the string $source</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>static-base-uri</xqdoc:name>
   <xqdoc:signature>static-base-uri() as xs:anyURI?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the value of the base URI property from the static context. If the base-uri property is undefined, the empty sequence is returned.</xqdoc:description>
    <xqdoc:return>xs:anyURI? : The base URI from the static context</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>string</xqdoc:name>
   <xqdoc:signature>string() as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the value of the context item as xs:string. If the context item is undefined, an error is raised.</xqdoc:description>
    <xqdoc:return>xs:string : the value of the context item as an xs:string</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>string</xqdoc:name>
   <xqdoc:signature>string($arg as item()?) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the value of $arg as xs:string. If the value of $arg is the empty sequence, the zero-length string is returned. If the context item of $arg is undefined, an error is raised.</xqdoc:description>
    <xqdoc:param>$arg? The sequence to get the vaule of as an xs:string</xqdoc:param>
    <xqdoc:return>xs:string : the value of $arg as an xs:string</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>string-join</xqdoc:name>
   <xqdoc:signature>string-join($arg as xs:anyAtomicType*) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns a xs:string created by concatenating the members of the $arg sequence using $separator as a separator. If the value of the separator is the zero-length string, then the members of the sequence are concatenated without a separator. The effect of calling the single-argument version of this function is the same as calling the two-argument version with $separator set to a zero-length string.</xqdoc:description>
    <xqdoc:param>$arg* The sequence to be joined to form the string. If it is empty, a zero-length string is returned.</xqdoc:param>
    <xqdoc:return>xs:string : the joined string</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>string-join</xqdoc:name>
   <xqdoc:signature>string-join($arg as xs:anyAtomicType*, $separator as xs:string) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns a xs:string created by concatenating the members of the $arg sequence using $separator as a separator. If the value of the separator is the zero-length string, then the members of the sequence are concatenated without a separator.</xqdoc:description>
    <xqdoc:param>$arg* The sequence to be joined to form the string. If it is empty, a zero-length string is returned.</xqdoc:param>
    <xqdoc:param>$separator The separator to be placed in the string between the items of $arg</xqdoc:param>
    <xqdoc:return>xs:string : the joined string</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>string-length</xqdoc:name>
   <xqdoc:signature>string-length() as xs:integer</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:integer equal to the length in characters of the value of the context item.
If the context item is undefined an error is raised. </xqdoc:description>
    <xqdoc:return>xs:integer : the length in characters</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>string-length</xqdoc:name>
   <xqdoc:signature>string-length($arg as xs:string?) as xs:integer</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:integer equal to the length in characters of the value of $arg.
If the value of $arg is the empty sequence, the xs:integer 0 is returned.
If no argument is supplied, $arg defaults to the string value (calculated using fn:string()) of the context item (.). If no argument is supplied or if the argument is the context item and the context item is undefined an error is raised</xqdoc:description>
    <xqdoc:param>$arg? The input string</xqdoc:param>
    <xqdoc:return>xs:integer : the length in characters</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>string-to-codepoints</xqdoc:name>
   <xqdoc:signature>string-to-codepoints($arg as xs:string?) as xs:integer*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the sequence of unicode code points that constitute an xs:string. If $arg is a zero-length string or the empty sequence, the empty sequence is returned.</xqdoc:description>
    <xqdoc:param>$arg? The input string</xqdoc:param>
    <xqdoc:return>xs:integer* : the sequence of code points</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>subsequence</xqdoc:name>
   <xqdoc:signature>subsequence($source as item()*, $starting-at as xs:double) as item()*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns a subsequence of the items in $source-sequence, items starting at the position, $starting-at, up to the end of the sequence are included.</xqdoc:description>
    <xqdoc:param>$source* The source sequence</xqdoc:param>
    <xqdoc:param>$starting-at The starting position in the $source</xqdoc:param>
    <xqdoc:return>item()* : the subsequence</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>subsequence</xqdoc:name>
   <xqdoc:signature>subsequence($source as item()*, $starting-at as xs:double, $length as xs:double) as item()*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns a subsequence of the items in $source, starting at the position, $starting-at,  including the number of items indicated by $length.</xqdoc:description>
    <xqdoc:param>$source* The source sequence</xqdoc:param>
    <xqdoc:param>$starting-at The starting position in the $source</xqdoc:param>
    <xqdoc:param>$length The length of the subsequence</xqdoc:param>
    <xqdoc:return>item()* : the subsequence</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>substring</xqdoc:name>
   <xqdoc:signature>substring($source as xs:string?, $starting-at as xs:double) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the portion of the value of $source beginning at the position indicated by the value of $starting-at and continuing to the end of $source. The characters returned do not extend beyond the end of $source. If $starting-at is zero or negative, only those characters in positions greater than zero are returned.If the value of $source is the empty sequence, the zero-length string is returned.</xqdoc:description>
    <xqdoc:param>$source? The source string</xqdoc:param>
    <xqdoc:param>$starting-at The starting position</xqdoc:param>
    <xqdoc:return>xs:string : the substring</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>substring</xqdoc:name>
   <xqdoc:signature>substring($source as xs:string?, $starting-at as xs:double, $length as xs:double) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the portion of the value of $source beginning at the position indicated by the value of $starting-at and continuing for the number of characters indicated by the value of $length. The characters returned do not extend beyond the end of $source. If $starting-at is zero or negative, only those characters in positions greater than zero are returned. If the value of $source is the empty sequence, the zero-length string is returned.</xqdoc:description>
    <xqdoc:param>$source? The source string</xqdoc:param>
    <xqdoc:param>$starting-at The starting position</xqdoc:param>
    <xqdoc:param>$length The number of characters in the substring</xqdoc:param>
    <xqdoc:return>xs:string : the substring</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>substring-after</xqdoc:name>
   <xqdoc:signature>substring-after($source as xs:string?, $search as xs:string?) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the substring of the value of $source that follows the first occurrence of a sequence of the value of $search. If the value of $source or $search is the empty sequence it is interpreted as the zero-length string. If the value of $search is the zero-length string, the zero-length string is returned. If the value of $source does not contain a string that is equal to the value of $search, the zero-length string is returned.</xqdoc:description>
    <xqdoc:param>$source? The input string</xqdoc:param>
    <xqdoc:param>$search? The search string</xqdoc:param>
    <xqdoc:return>xs:string : the substring after $search</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>substring-after</xqdoc:name>
   <xqdoc:signature>substring-after($source as xs:string?, $search as xs:string?, $collation-uri as xs:string) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the substring of the value of $source that follows the first occurrence of a sequence of the value of $search in the collation $collation-uri. If the value of $source or $search is the empty sequence it is interpreted as the zero-length string. If the value of $search is the zero-length string, the zero-length string is returned. If the value of $source does not contain a string that is equal to the value of $search, the zero-length string is returned. The third argument $collation-uri is either: 1) the full URI e.g. "http://www.w3.org/2013/collation/UCA?lang=en;strength=secondary", or 2) relative where you only need to specify the last part of a valid full collation-uri, e.g. "?lang=sv-SE", "lang=sv-SE;strength=primary;decomposition=standard" or "swedish".</xqdoc:description>
    <xqdoc:param>$source? The input string</xqdoc:param>
    <xqdoc:param>$search? The search string</xqdoc:param>
    <xqdoc:param>$collation-uri The collation URI</xqdoc:param>
    <xqdoc:return>xs:string : the substring after $search</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>substring-before</xqdoc:name>
   <xqdoc:signature>substring-before($source as xs:string?, $search as xs:string?) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the substring of the value of $source that precedes the first occurrence of a sequence of the value of $search. If the value of $source or $search is the empty sequence it is interpreted as the zero-length string. If the value of $search is the zero-length string, the zero-length string is returned. If the value of $source does not contain a string that is equal to the value of $search, the zero-length string is returned.</xqdoc:description>
    <xqdoc:param>$source? The input string</xqdoc:param>
    <xqdoc:param>$search? The search string</xqdoc:param>
    <xqdoc:return>xs:string : the substring before $search</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>substring-before</xqdoc:name>
   <xqdoc:signature>substring-before($source as xs:string?, $search as xs:string?, $collation-uri as xs:string) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the substring of the value of $source that precedes the first occurrence of a sequence of the value of $search in the collation $collation-uri. If the value of $source or $search is the empty sequence it is interpreted as the zero-length string. If the value of $search is the zero-length string, the zero-length string is returned. If the value of $source does not contain a string that is equal to the value of $search, the zero-length string is returned. The third argument $collation-uri is either: 1) the full URI e.g. "http://www.w3.org/2013/collation/UCA?lang=en;strength=secondary", or 2) relative where you only need to specify the last part of a valid full collation-uri, e.g. "?lang=sv-SE", "lang=sv-SE;strength=primary;decomposition=standard" or "swedish".</xqdoc:description>
    <xqdoc:param>$source? The input string</xqdoc:param>
    <xqdoc:param>$search? The search string</xqdoc:param>
    <xqdoc:param>$collation-uri The collation URI</xqdoc:param>
    <xqdoc:return>xs:string : the substring before $search</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>sum</xqdoc:name>
   <xqdoc:signature>sum($arg as xs:anyAtomicType*) as xs:anyAtomicType</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns a value obtained by adding together the values in $arg. If $arg is the the empty sequence the xs:double value 0.0e0 is returned.</xqdoc:description>
    <xqdoc:param>$arg* The sequence of numbers to be summed up</xqdoc:param>
    <xqdoc:return>xs:anyAtomicType : the sum of all numbers in $arg</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>sum</xqdoc:name>
   <xqdoc:signature>sum($arg as xs:anyAtomicType*, $default as xs:anyAtomicType?) as xs:anyAtomicType?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns a value obtained by adding together the values in $arg. If $arg is the the empty sequence then $default is returned.</xqdoc:description>
    <xqdoc:param>$arg* The sequence of numbers to be summed up</xqdoc:param>
    <xqdoc:param>$default? The default value if $arg computes to the empty sequence</xqdoc:param>
    <xqdoc:return>xs:anyAtomicType? : the sum of all numbers in $arg</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>tail</xqdoc:name>
   <xqdoc:signature>tail($sequence as item()*) as item()*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>The function returns the value of the expression subsequence($sequence, 2), i.e. a new sequence containing all items of the input sequence except the first.</xqdoc:description>
    <xqdoc:param>$sequence* The source sequence</xqdoc:param>
    <xqdoc:return>item()* : the resulting sequence</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>timezone-from-date</xqdoc:name>
   <xqdoc:signature>timezone-from-date($date as xs:date?) as xs:dayTimeDuration?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the timezone component of $date if any. If $date has a timezone component, then the result is an xs:dayTimeDuration that indicates deviation from UTC; its value may range from +14:00 to -14:00 hours, both inclusive. Otherwise, the result is the empty sequence.If $date is the empty sequence, returns the empty sequence.</xqdoc:description>
    <xqdoc:param>$date? The date as xs:date</xqdoc:param>
    <xqdoc:return>xs:dayTimeDuration? : the timezone component from $date</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>timezone-from-dateTime</xqdoc:name>
   <xqdoc:signature>timezone-from-dateTime($date-time as xs:dateTime?) as xs:dayTimeDuration?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the timezone component of $date-time if any. If $date-time has a timezone component, then the result is an xdt:dayTimeDuration that indicates deviation from UTC; its value may range from +14:00 to -14:00 hours, both inclusive. Otherwise, the result is the empty sequence.</xqdoc:description>
    <xqdoc:param>$date-time? The date-time as xs:dateTime</xqdoc:param>
    <xqdoc:return>xs:dayTimeDuration? : the timezone component from $date-time</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>timezone-from-time</xqdoc:name>
   <xqdoc:signature>timezone-from-time($time as xs:time?) as xs:dayTimeDuration?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the timezone component of $time if any. If $time has a timezone component, then the result is an xdt:dayTimeDuration that indicates deviation from UTC; its value may range from +14:00 to -14:00 hours, both inclusive. Otherwise, the result is the empty sequence.</xqdoc:description>
    <xqdoc:param>$time? The time as xs:time</xqdoc:param>
    <xqdoc:return>xs:dayTimeDuration? : the timezone component from $time</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>tokenize</xqdoc:name>
   <xqdoc:signature>tokenize($input as xs:string?) as xs:string*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Breaks the input string $input into a sequence of strings, </xqdoc:description>
    <xqdoc:param>$input? The input string</xqdoc:param>
    <xqdoc:return>xs:string* : the token sequence</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>tokenize</xqdoc:name>
   <xqdoc:signature>tokenize($input as xs:string?, $pattern as xs:string) as xs:string*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Breaks the input string $input into a sequence of strings, </xqdoc:description>
    <xqdoc:param>$input? The input string</xqdoc:param>
    <xqdoc:param>$pattern The tokenization pattern</xqdoc:param>
    <xqdoc:return>xs:string* : the token sequence</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>tokenize</xqdoc:name>
   <xqdoc:signature>tokenize($input as xs:string?, $pattern as xs:string, $flags as xs:string) as xs:string*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Breaks the input string $input into a sequence of strings, </xqdoc:description>
    <xqdoc:param>$input? The input string</xqdoc:param>
    <xqdoc:param>$pattern The tokenization pattern</xqdoc:param>
    <xqdoc:param>$flags The flags</xqdoc:param>
    <xqdoc:return>xs:string* : the token sequence</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>trace</xqdoc:name>
   <xqdoc:signature>trace($value as item()*, $label as xs:string) as item()*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>This function is intended to be used in debugging queries by providing a trace of their execution. The input $value is returned, unchanged, as the result of the function. In addition, the inputs $value, converted to an xs:string, and $label is directed to a trace data set in the eXist log files.</xqdoc:description>
    <xqdoc:param>$value* The value</xqdoc:param>
    <xqdoc:param>$label The label in the log file</xqdoc:param>
    <xqdoc:return>item()* : the labelled $value in the log</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>translate</xqdoc:name>
   <xqdoc:signature>translate($arg as xs:string?, $map as xs:string, $trans as xs:string) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the value of $arg modified so that every character in the value of $arg that occurs at some position N in the value of $map has been replaced by the character that occurs at position N in the value of $trans.

If the value of $arg is the empty sequence, the zero-length string is returned.

Every character in the value of $arg that does not appear in the value of $map is unchanged.

Every character in the value of $arg that appears at some position M in the value of $map, where the value of $trans is less than M characters in length, is omitted from the returned value. If $map is the zero-length string $arg is returned.

If a character occurs more than once in $map, then the first occurrence determines the replacement character. If $trans is longer than $map, the excess characters are ignored.

i.e. fn:translate("bar","abc","ABC") returns "BAr"</xqdoc:description>
    <xqdoc:param>$arg? The string to be translated</xqdoc:param>
    <xqdoc:param>$map The map string</xqdoc:param>
    <xqdoc:param>$trans The translation string</xqdoc:param>
    <xqdoc:return>xs:string : the translated string</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>true</xqdoc:name>
   <xqdoc:signature>true() as xs:boolean</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Always returns the boolean value true</xqdoc:description>
    <xqdoc:return>xs:boolean : true</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>unordered</xqdoc:name>
   <xqdoc:signature>unordered($arg as item()*) as item()*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Takes a sequence $arg as input and returns an arbitrary implementation dependent permutation of it. Currently, this has no effect in eXist, but it might be used for future optimizations.</xqdoc:description>
    <xqdoc:param>$arg* The input sequence</xqdoc:param>
    <xqdoc:return>item()* : the input sequence in an arbitrary implementation dependent permutation</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>unparsed-text</xqdoc:name>
   <xqdoc:signature>unparsed-text($href as xs:string?) as xs:string?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>reads an external resource (for example, a file) and returns a string representation of the resource</xqdoc:description>
    <xqdoc:param>$href? the URI to load text from</xqdoc:param>
    <xqdoc:return>xs:string?</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>unparsed-text</xqdoc:name>
   <xqdoc:signature>unparsed-text($href as xs:string?, $encoding as xs:string) as xs:string?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>reads an external resource (for example, a file) and returns a string representation of the resource</xqdoc:description>
    <xqdoc:param>$href? the URI to load text from</xqdoc:param>
    <xqdoc:param>$encoding character encoding of the resource</xqdoc:param>
    <xqdoc:return>xs:string?</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>unparsed-text-available</xqdoc:name>
   <xqdoc:signature>unparsed-text-available($href as xs:string?) as xs:boolean</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>determines whether a call on the fn:unparsed-text function with identical arguments would return a string</xqdoc:description>
    <xqdoc:param>$href? the URI to load text from</xqdoc:param>
    <xqdoc:return>xs:boolean</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>unparsed-text-available</xqdoc:name>
   <xqdoc:signature>unparsed-text-available($href as xs:string?, $encoding as xs:string) as xs:boolean</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>determines whether a call on the fn:unparsed-text function with identical arguments would return a string</xqdoc:description>
    <xqdoc:param>$href? the URI to load text from</xqdoc:param>
    <xqdoc:param>$encoding character encoding of the resource</xqdoc:param>
    <xqdoc:return>xs:boolean</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>unparsed-text-lines</xqdoc:name>
   <xqdoc:signature>unparsed-text-lines($href as xs:string?) as xs:string*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>reads an external resource (for example, a file) and returns its contents as a sequence of strings, one for each line of text in the string representation of the resource</xqdoc:description>
    <xqdoc:param>$href? the URI to load text from</xqdoc:param>
    <xqdoc:return>xs:string*</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>unparsed-text-lines</xqdoc:name>
   <xqdoc:signature>unparsed-text-lines($href as xs:string?, $encoding as xs:string) as xs:string*</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>reads an external resource (for example, a file) and returns its contents as a sequence of strings, one for each line of text in the string representation of the resource</xqdoc:description>
    <xqdoc:param>$href? the URI to load text from</xqdoc:param>
    <xqdoc:param>$encoding character encoding of the resource</xqdoc:param>
    <xqdoc:return>xs:string*</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>upper-case</xqdoc:name>
   <xqdoc:signature>upper-case($arg as xs:string?) as xs:string</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the value of $arg after translating every character to its upper-case correspondent as defined in the appropriate case mappings section in the Unicode standard. For versions of Unicode beginning with the 2.1.8 update, only locale-insensitive case mappings should be applied. Beginning with version 3.2.0 (and likely future versions) of Unicode, precise mappings are described in default case operations, which are full case mappings in the absence of tailoring for particular languages and environments. Every lower-case character that does not have an upper-case correspondent, as well as every upper-case character, is included in the returned value in its original form.</xqdoc:description>
    <xqdoc:param>$arg? The text to be converted to all upper-case characters</xqdoc:param>
    <xqdoc:return>xs:string : the resulting upper-case text</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>year-from-date</xqdoc:name>
   <xqdoc:signature>year-from-date($date as xs:date?) as xs:integer?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:integer representing the year in the localized value of $date. The value may be negative.</xqdoc:description>
    <xqdoc:param>$date? The date as xs:date</xqdoc:param>
    <xqdoc:return>xs:integer? : the year component from $date</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>year-from-dateTime</xqdoc:name>
   <xqdoc:signature>year-from-dateTime($date-time as xs:dateTime?) as xs:integer?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:integer representing the year in the localized value of $date-time. The value may be negative.</xqdoc:description>
    <xqdoc:param>$date-time? The date-time as xs:dateTime</xqdoc:param>
    <xqdoc:return>xs:integer? : the year component from $date-time</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>years-from-duration</xqdoc:name>
   <xqdoc:signature>years-from-duration($duration as xs:duration?) as xs:integer?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns an xs:integer representing the years component in the canonical lexical representation of the value of $duration. The result may be negative.</xqdoc:description>
    <xqdoc:param>$duration? The duration as xs:duration</xqdoc:param>
    <xqdoc:return>xs:integer? : the years component of $duration</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
  <xqdoc:function>
   <xqdoc:name>zero-or-one</xqdoc:name>
   <xqdoc:signature>zero-or-one($arg as item()*) as item()?</xqdoc:signature>
   <xqdoc:comment>
    <xqdoc:description>Returns the argument sequence $arg if it contains zero or one items. Otherwise, raises an error.</xqdoc:description>
    <xqdoc:param>$arg* The sequence to be tested for cardinality</xqdoc:param>
    <xqdoc:return>item()? : the input sequence if it contains zero or one items.</xqdoc:return>
   </xqdoc:comment>
  </xqdoc:function>
 </xqdoc:functions>
</xqdoc:xqdoc>